---
title: "09-ASXL1_Tcell_and_Rescue"
author: "Maggie Fu"
date: '2023-05-19'
output: html_document
---

```{r setup, include=FALSE}
# Work directory
setwd("/mnt/scratch/KoborLab/Personal_Folders/mfu/Projects/ASXL1/")
.libPaths(c("/mnt/scratch/KoborLab/R_Libs/4.3/",
            "/mnt/koborlab-hpc/tools/R/library/4",
            "/usr/local/lib/R/site-library",
            "/usr/lib/R/site-library", "/usr/lib/R/library"))
.libPaths( "/usr/local/lib/R/site-library")
# Packages
## For loading DNAm data
library(minfi)
library(data.table)
library(IlluminaHumanMethylationEPICv2manifest,lib.loc = "/mnt/scratch/KoborLab/R_Libs/4.3.2/")
# BiocManager::install("jokergoo/IlluminaHumanMethylationEPICv2anno.20a1.hg38")
library(IlluminaHumanMethylationEPICv2anno.20a1.hg38)
# library(methylumi)
# library(ewastools, lib.loc = "/mnt/scratch/KoborLab/R_Libs/4.2.2") # (supports EPIC_v2)
## Preprocessing
library(wateRmelon)
library(sva)
library(Metrics)
## Basic data manipulation / plotting
library(dplyr)
library(ggplot2)
library(ggvenn)
## Cell type prediction
library(FlowSorted.Blood.EPIC)
library(ExperimentHub)
library(pheatmap)
library(eulerr)
## DNAm age
library(methylclock)
## Parallel processing
library(pbapply)
## EWAS
library(MASS)
library(sfsmisc)
## Enrichment analysis
library(msigdbr)
library(clusterProfiler)
library(org.Hs.eg.db)
library(fgsea)
library(R.utils)
library(missMethyl)
## Color palette
library(cartography)
library(nord)

# Define colors for plotting
group.colors <- c("family control" = "#4B3232FF", "unrelated healthy control" = "#193264FF", "patient empty vector" ="#550307FF", "patient wild type" = "#4B644BFF")
group.colors <- c("EV" ="#550307FF", "WT" = "#4B644BFF")

# Internal functions
source("/mnt/scratch/KoborLab/Personal_Folders/mfu/Functions/DetPvalTestRG.R")
source("/mnt/scratch/KoborLab/Personal_Folders/mfu/Functions/locfdr_LMM.R")
source("/mnt/scratch/KoborLab/Personal_Folders/mfu/Functions/SexAgePrediction_RG.R")
source("/mnt/scratch/KoborLab/Personal_Folders/mfu/Functions/BetaPlot.R")

```

## Preprocessing

Try to keep the preprocessing steps similar to the whole blood analysis
- Sample / probe QC
- Funnorm
- 

#### Reading IDATs

```{bash}
cd /mnt/cifs/maggie.fu/fs/KoborLab/raw_data/BRAINSTORM-KoborArchive2014March/RAW\ Data\ -\ DNA\ methylation/RAW\ data\ -\ EPIC\ methylation/2023/Turvey_May2023
scp -r * /mnt/scratch/KoborLab/Personal_Folders/mfu/Projects/ASXL1/raw/
cd /mnt/scratch/KoborLab/Personal_Folders/mfu/Projects/ASXL1/raw/207057130152/
mv *.idat ../
cd ../
rm -r 207057130152
```

```{r}
rawDir <- "raw"
targets <- read.metharray.sheet(rawDir)
RGset <- read.metharray.exp(base = rawDir, targets = targets, extended = T, recursive = T)
pheno <- pData(RGset)

# reassign the annotation so that the minfi functions getBeta(), preprocessRaw() and others like preprocessNoob() will work
annotation(RGset)["array"] <- "IlluminaHumanMethylationEPICv2"
annotation(RGset)["annotation"] <- "20a1.hg38"
(manifest <- getManifest(RGset))

saveRDS(RGset, file = "RData/901-ASXL1_Tcell_RGset.rds")
```

### Normalization

```{r}
RGset <- readRDS("RData/901-ASXL1_Tcell_RGset.rds")
anno <- readRDS("/mnt/scratch/KoborLab/Personal_Folders/mfu/Reference/EPICv2_fdat.rds")

GRset <- preprocessFunnorm(RGset)
```

### Sample QC

```{r}
# EWAStools
ewas_meth <- read_idats(pData(RGset)$Basename)
ctrls <- control_metrics(ewas_meth)
pData(GRset)$failed <- sample_failure(ctrls)
table(pData(GRset)$failed)

# minfi
minfi_controlqc <- getQC(preprocessRaw(RGset))
controlqc <- plotQC(minfi_controlqc)

# Other checks
out1 <- DetPBisCTest(RGset)
out2 <- detectOutlier(as.matrix(getBeta(GRset))) %>% which(.) # Take too long to run
out3 <- outlyx(RGset) 
out4 <- locfdr_LMM(getBeta(GRset), pData(GRset))

# No outliers! All samples' quality is good
```

### Probe QC

```{r}
detP <- minfi::detectionP(as(RGset, "RGChannelSet"))
bc <- beadcount(RGset)
RGset <- pfilter(RGset, pn = detP, bc = bc, pnthresh = 0.001)
# 0 samples having 1 % of sites with a detection p-value greater than 0.001 were removed 
# Samples removed:  
# 8659 sites were removed as beadcount <3 in 5 % of samples 
# 3535 sites having 1 % of samples with a detection p-value greater than 0.001 were removed 
GRset <- preprocessFunnorm(RGset$mn)
```

### Remove duplicated probes???
Weird duplicated probe names _TC / _BC - remove duplicated ones

```{r}
bt <- getBeta(GRset)
probes <- gsub("_.*", "", rownames(bt)) %>% unique()
bt_dup <- bt[duplicated(gsub("_.*", "", rownames(bt))), ] # remove these
dim(bt_dup)
bt_dup2 <- bt[!duplicated(gsub("_.*", "", rownames(bt))), ] # keep these
dim(bt_dup2)

GRset <- GRset[rownames(bt_dup2), ]
rownames(GRset) <- gsub("_.*", "", rownames(GRset))

dim(GRset) #923736      8
dim(anno) #infinium-methylationepic-v-1-0-b5-manifest-file     52
intersect(rownames(GRset), anno$IlmnID) %>% length() #721378 - why is the overlap so low???

overlap <- intersect(rownames(GRset), anno$IlmnID)
GRset <- GRset[overlap, ]
rownames(anno) <- anno$IlmnID
anno <- anno[overlap, ]
```

```{r}
beta <- getBeta(GRset)
meta <- pData(GRset)

# Relabel things
meta$Sample_Group <- gsub("sister|mom|Dad", "family control", meta$Sample_Group) %>% 
    gsub("HC.*", "unrelated healthy control", .) %>% 
    gsub("P_WT.*", "patient wild type", .) %>%
    gsub("P_EU", "patient empty vector", .)
meta$Sample_Name <- gsub("EU", "EV", meta$Sample_Name) %>% 
    gsub("sister", "Sister", .) %>% 
    gsub("mom", "Mom", .)
meta$Sentrix_row <- gsub("C.*", "", meta$Array) %>% gsub("R", "", .) %>% as.integer()
colnames(beta) <- meta$Sample_Name
rownames(meta) <- meta$Sample_Name


save(beta, meta, anno, file = "RData/902-ASXL1_Tcell_betas_norm.RData")
```


## Data exploration - cell type, DNAm age, sex, etc

### Check sex

```{r}
BetaPlot <- function(bt, mt, var){
    if(nrow(bt) > 20000){
        n <- 20000
    } else {
        n <- nrow(bt)
    }
    bt.m <- reshape2::melt(bt[sample(1:nrow(bt),n),])
    #remove NAs before plotting (otherwise get many non-inifnite warnings)
    plt <- bt.m[which(!(is.na(bt.m$value))),]
        
    # Add meta
    colnames(plt) <- c("CpG","ID","Beta")
    plt <- merge(plt, mt, by.x = "ID", by.y = 0) %>% 
        as.data.frame()
        
    ggplot(plt, aes(Beta, group = ID, color = get(var))) +
        geom_density() +
        theme_bw() +
        labs(x = "DNAm Beta Value")
}

BetaPlot(beta[anno$CHR == "X", ], meta, "predictedSex") #remove all outliers
BetaPlot(beta[anno$CHR == "Y", ], meta,  "predictedSex") 

# Mom and Dad got switched 
meta$Sample_Name[rownames(meta) == "Mom"] <- "Dad"
meta$Sample_Name[rownames(meta) == "Dad"] <- "Mom"
rownames(meta)[meta$Sample_Name == "Mom"] <- "Mom2"
rownames(meta)[meta$Sample_Name == "Dad"] <- "Dad"
rownames(meta)[meta$Sample_Name == "Mom"] <- "Mom" # id column keeps the original (wrong) labeling
```

### Check SNPs

```{r}
snps <- getSnpBeta(RGset)
colnames(snps) <- meta$Sample_Group
D <- dist(t(snps)) #snp probes
hc <- hclust(D, method = "ward.D2")
ggdendrogram(hc, rotate = TRUE)
```

### EstimateCellCounts2

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")

dataset <- beta

# ECC2 doesn't work - need to run homebrew MRP 
source("../../Functions/MRP_accessory.R")
source("../../Functions/pickCompProbesCaret.R")

if (verbose)
    cat("Loading Reference Dataset.\n")
load("/mnt/scratch/KoborLab/Personal_Folders/mfu/Projects/MRP/reference/FlowSorted.BloodExtended.EPIC_FN.RData")

sampType = rep("PB", ncol(dataset)) # c("PB", "CB")
class = "betas" # c("rgset", "betas")
norm = "QN.b" # c("Noob", "FN", "QN", "QN.b", "none")
normComb = TRUE
probeList = "Ttest" #c("Ttest", "Caret", "IDOL", "DHS")
method = "CP" #c("CP", "RPC", "SVR")
probeSelect = "both" #c("both", "any", "pval")
conditions = NULL
nProbes = 100
verbose = TRUE
plotRef = FALSE
removenRBC = T
EPIConly = F
seed = 3
reference = FlowSorted.BloodExtended.EPIC.FN # c(FlowSorted.CordBlood.450k.FN, FlowSorted.Blood.450k.FN, FlowSorted.Blood.EPIC.FN, FlowSorted.BloodExtended.EPIC.FN)
cellTypes = c("Bas", "Bmem", "Bnv", "CD4mem", "CD4nv",
              "CD8mem", "CD8nv", "Eos", "Mono", "Neu", "NK", "Treg")
caretMods = c("EL", "BLR", "CART", "RF", "GBM", "RFEnNB", "RFEnSVM") # c("EL", "BLR", "CART", "RF", "GBM", "RFEnLDA", "RFEnRF", "RFEnNB", "RFEnSVM", "RFEnNN")

require(dplyr)
require(limma)
require(genefilter)
#require(FlowSorted.Blood.450k)
require(FlowSorted.Blood.EPIC)
#require(FlowSorted.CordBloodCombined.450k)
require(IlluminaHumanMethylation450kmanifest)
require(IlluminaHumanMethylationEPICmanifest)
#require(ExperimentHub)
#require(EpiDISH)
#hub <- ExperimentHub()
library(SIS)
```

#### Combine data / normalize

```{r}
if (verbose)
    cat("Starting Cell Type Estimation.\n")
# if (removenRBC == T) {
#     cellTypes <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran")
# } else {
#     cellTypes <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran", "nRBC")
# }
if (norm == "FN") {
    processMethod <- "preprocessFunnorm"
    if (class == "betas") stop("A RGChannelSet is required for functional normalization")
} else if (norm == "Noob") {
    processMethod <- "preprocessNoob"
    if (class == "betas") stop("A RGChannelSet or is required for Noob normalization")
} else if (norm == "QN") {
    processMethod <- "preprocessQuantile"
    if (class == "betas") stop("A RGChannelSet is required for this quantile normalization method. If you only have betas, set normalization method to QN.b instead")
} else if (norm == "QN.b") {
    processMethod <- "normalizeQuantiles"
    if (class == "rgset") stop("QN.b is exclusively for beta matrix input. Use QN instead if you have an RGChannelSet")
}
sampCT <- rep("WBC", ncol(dataset))
if (norm != "none") {
    processMethod <- get(processMethod)
}

### Data normalization
if (verbose) 
    cat("Combining Data with Flow Sorted Data and Normalizing.\n")
if (class == "betas") {
    # if (all(sampType %in% "CB")) {
    #     ref <- betas(reference[pData(reference)$SampType == "CB", ])
    # } else {
    #     ref <- betas(reference)
    # }
    if (class(reference) == "MethyLumiSet"){
        ref <- betas(reference)
    } else if (class(reference) %in% c("RGChannelSetExtended", "RGChannelSet", "GenomicRatioSet")){
        ref <- getBeta(reference)
    }
    commonprobe <- intersect(as.character(rownames(dataset)), as.character(rownames(ref)))
    if (norm == "QN.b") { 
        comb <- cbind(dataset[commonprobe, ], ref[commonprobe, ])
        comb.n <- processMethod(comb) 
        samp.n <- comb.n[, colnames(dataset)]
        ref.n <- comb.n[, colnames(ref)]
    } else if (norm == "none") {
        samp.n <- dataset[commonprobe, ]
        ref.n <- ref[commonprobe, ]
    }
} else {
    dataset <- as(dataset, "RGChannelSet")
    if (norm == "none") {
        commonprobe <- intersect(as.character(rownames(dataset)), as.character(rownames(BloodCell)))
        samp.n <- betas(BloodCell)[commonprobe, ]
        ref.n <- getBeta(dataset)[commonprobe, ]
        
    } else if (normComb) { # Combine all the datasets and normalize
        combRGset <- combineArrays(dataset, reference, outType = "IlluminaHumanMethylation450k")
        combRGset.N <- processMethod(combRGset)
        comb.n <- getBeta(combRGset.N)
        samp.n <- comb.n[, colnames(dataset)]
        ref.n <- comb.n[, colnames(reference)]
    } 
    
}

combMeta <- data.frame(sampleNames = c(colnames(samp.n), colnames(ref.n)),
                       studyIndex = rep(c("user", "reference"), times = c(ncol(samp.n), ncol(ref.n))),
                       sampleType = c(sampType, as.character(pData(reference)$SampType)),
                       cellType = c(sampCT, as.character(pData(reference)$CellType)), 
                       stringsAsFactors = FALSE)
refMeta <- combMeta[combMeta$studyIndex == "reference", ]
sampMeta <- combMeta[combMeta$studyIndex == "user", ]

# save(ref.n, samp.n, combMeta, file = "MRPref_CHILD_FN_0.RData")
# save(ref.n, samp.n, combMeta, file = "MRPref_CHILD_FN_1.RData")
# save(ref.n, samp.n, combMeta, file = "MRPref_CHILD_FN_5.RData")
```

#### Pick probes

```{r}
### Pick probes and estimate weights
if (verbose)
    cat("Estimating Weights for Cell Type Prediction Based on Selected Probeset.\n")
if (probeList == "Ttest") {
    coefs <- pickCompProbes2(betas = ref.n, 
                             meta = refMeta, 
                             nP = nProbes,
                             ct = cellTypes, 
                             ps = probeSelect, 
                             p.val = 0.05, 
                             min.delta.beta = 0, 
                             plot = plotRef) # Call the pickCompProbes2 function below to select the probes that can best discern cell types and calculate weights
} else if (probeList == "Caret") {
    coefs_caret <- pickCompProbesCaret(betas = ref.n, 
                                       meta = refMeta, 
                                       ct = cellTypes, 
                                       caretMods = caretMods, # caretMods = c("EL", "BLR", "CART", "RF", "GBM", "LDA", "RFEnRF", "RFEnNB", "RFEnSVM", "RFEnNN")
                                       verbose = verbose, 
                                       filtern = 10000,
                                       seed = seed)
} else {
    load("/mnt/scratch/KoborLab/Personal_Folders/mfu/Reference/Probe_libraries.RData")
    if (probeList == "IDOL") {
        if (unique(sampType) == "CB") {
            pLib <- idol.c
        } else if (nrow(samp.n) > 622399) {
            pLib <- idol.a_EPIC
        } else {
            pLib <- idol.a_450
        }
    } else if (probeList == "DHS") {
        pLib <- DHS
    }
    coefs <- pickCompProbes2(betas = ref.n, meta = refMeta, nP = nProbes, 
                             ct = cellTypes, trainingProbes = pLib, plot = plotRef) 
}

```

#### Estimate proportion

```{r}
### Estimate cell type proportion
if (verbose)
    cat("Estimating Composition Based on Selected Projection Method.\n")
projectionMethod <- get(method)

if (probeList == "Caret"){
    out <- lapply(coefs_caret$probeCoefs, function(coefs){
        mat <- samp.n[rownames(coefs), ]
        mat <- as.matrix(mat[complete.cases(mat), ])
        mat.cb <- mat[, sampMeta$sampleType == "CB"]
        mat.pb <- mat[, sampMeta$sampleType == "PB"]
        coefs.cb <- as.matrix(coefs)
        coefs.pb <- coefs.cb[, colnames(coefs.cb) != "nRBC"] # For peripheral blood, remove nRBC in prediction
        if (ncol(mat.cb) > 0) {
            if (is.null(conditions)) counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb) %>% 
                    as.data.frame()# Using the weights generated in the last step to stimate the proportion of each cell type
            else counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb, conditions = conditions) %>% 
                    as.data.frame()
        } 
        if (ncol(mat.pb) > 0) {
            if (is.null(conditions)) counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb) %>% 
                    as.data.frame()
            else counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb, conditions = conditions) %>% 
                    as.data.frame()
            counts.pb$nRBC <- 0
        }
        if (exists("counts.cb") & exists("counts.pb")) {
            counts <- rbind(counts.cb, counts.pb) %>% .[colnames(mat), ]
        } else if (exists("counts.cb") & !exists("counts.pb")) {
            counts <- counts.cb
        } else if (!exists("counts.cb") & exists("counts.pb")) {
            counts <- counts.pb
        }
        return(counts)
    })
} else {
    mat <- samp.n[rownames(coefs), ]
    mat <- as.matrix(mat[complete.cases(mat), ])
    mat.cb <- mat[, sampMeta$sampleType == "CB"]
    mat.pb <- mat[, sampMeta$sampleType == "PB"]
    coefs.cb <- as.matrix(coefs)
    coefs.pb <- coefs.cb[, colnames(coefs.cb) != "nRBC"]
    if (ncol(mat.cb) > 0) {
        if (is.null(conditions)) counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb) %>% 
                as.data.frame() 
        else counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb, conditions = conditions) %>% 
                as.data.frame()
    } 
    if (ncol(mat.pb) > 0) {
        if (is.null(conditions)) counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb) %>% 
                as.data.frame()
        else counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb, conditions = conditions) %>% 
                as.data.frame()
        counts.pb$nRBC <- 0
    }
    if (exists("counts.cb") & exists("counts.pb")) {
        counts <- rbind(counts.cb, counts.pb) %>% .[colnames(mat), ]
    } else if (exists("counts.cb") & !exists("counts.pb")) {
        counts <- counts.cb
    } else if (!exists("counts.cb") & exists("counts.pb")) {
        counts <- counts.pb
    }
    out <- counts
}

# out <- list(counts = counts, coefs = coefs, betas.n = samp.n)
```

#### Plot cell type

```{r}
meta <- cbind(meta, out)

BloodPlot <- function(mt, vartype = c("categorical", "continuous"), varname = NULL, 
                      tissue = c("blood", "bloodextended", "cord")) {
    
    require(dplyr)
    require(ggpubr)
    require(gridExtra)
    
    if (tissue == "blood"){
        ct <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran")
    } else if (tissue == "bloodextended"){
        ct <- c("Bas", "Bmem", "Bnv", "CD4mem", "CD4nv",
                "CD8mem", "CD8nv", "Eos", "Mono", "Neu", "NK", "Treg")
    } else if (tissue == "Cord"){
        ct <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran", "nRBC")
    }
    counts <- mt[, c("Sample_Name", ct)] %>% as.data.table()
    counts_plot <- melt(counts, id.vars = "Sample_Name")
    covar <- mt[, c("Sample_Name", varname)]
    plt <- merge(counts_plot, covar, by = "Sample_Name") %>% 
        as.data.frame()
    
    p1 <- ggplot(plt, aes(get(varname), value, fill = get(varname))) +
        geom_boxplot(alpha = 0.2) +
        geom_point(shape = 21, aes(group = Sample_Name), 
                   position = position_jitter(w = 0.1)) +
        xlab(NULL) +
        ylab("Cell Proportion") +
        theme_bw() + 
        theme(axis.text = element_text(size = 12, color = "black"),
              axis.title = element_text(size = 14),
              legend.text = element_text(size = 11),
              legend.title = element_text(size = 14), 
              strip.text = element_text(size = 14),
              axis.text.x = element_blank(),
              axis.ticks.x = element_blank()) +
        facet_wrap(~ variable)
    
    # if (vartype == "categorical") {
    #     p1 <- p1 + stat_compare_means(method = "t.test")
    # } 
    plot(p1)
}

BloodPlot(mt = meta, vartype = "categorical", varname = "Sample_Group", tissue = "bloodextended") + 
    scale_fill_manual(values = group.colors) 

# Compare predicted and flow cell type proportion

cor.test(meta$CD4_perc_flow, meta$CD4_perc_DNAm)
cor.test(meta$CD8_perc_flow, meta$CD8_perc_DNAm)

ggplot(meta, aes(CD4_perc_DNAm, CD4_perc_flow)) + 
    geom_smooth(method = "lm", color = "gray") + 
    geom_point(aes(color = Sample_Group), size = 2.5) + 
    scale_color_manual(values = group.colors) + 
    theme_bw() + 
    theme(text = element_text(size = 14))
ggplot(meta, aes(CD8_perc_DNAm, CD8_perc_flow)) + 
    geom_smooth(method = "lm", color = "gray") + 
    geom_point(aes(color = Sample_Group), size = 2.5) + 
    scale_color_manual(values = group.colors) + 
    theme_bw() + 
    theme(text = element_text(size = 14))
```

#### Make cell type PCs

```{r}
source("../../Functions/pcaCoDa_NG.R")

ct <- meta[, c("CD4mem", "CD4nv", "CD8mem", "CD8nv", "Treg")] %>% 
    as.data.frame()
sum(ct==0) #Are there any proportions predicted to be 0?
ct <- (ct + 0.0001) #If necessary, add the offset of 0.001
min(ct) # Cannot be = or < 0

pca_object <- pcaCoDa(ct)
CTP <- as.data.frame(pca_object$scores)
colnames(CTP) <- c("CTP_PC1", "CTP_PC2", "CTP_PC3", "CTP_PC4")
rownames(CTP) <- rownames(ct)
identical(rownames(meta), rownames(CTP))
meta <- cbind(meta, CTP)

save(beta, meta, anno, file = "RData/902-ASXL1_Tcell_betas_norm.RData")
```

### DNAm age

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")

# DNAm Age
bt <- cbind(CpG = rownames(beta), as.data.frame(beta))
cpgs.missing <- checkClocks(bt)
DNAmage <- DNAmAge(bt, clocks = c("Horvath", "Hannum", "skinHorvath", "Levine", "Wu"))
meta <- cbind(meta, DNAmage[, 2:6])
meta$Sample_Group <- factor(meta$Sample_Group, level = c('unrelated healthy control', 'family control', 'patient empty vector', 'patient wild type'))

group.colors <- c("family control" = "#C0392BFF", "unrelated healthy control" = "#193264FF", "patient empty vector" ="#96281BFF", "patient wild type" = "#4B644BFF")
group.colors <- c("EV" ="#550307FF", "WT" = "#4B644BFF")

ggplot(as.data.frame(meta), aes(Sample_Group, Horvath, fill = Sample_Group)) + 
    geom_boxplot(alpha = 0.8) + 
    geom_point(size = 2, aes(color = Sample_Group)) +
    theme_bw() + 
    scale_fill_manual(values = group.colors) +
    scale_color_manual(values = group.colors) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), 
          text = element_text(size = 15)) + 
    labs(x = "", y = "Horvath Epigenetic Clock DNAm Age", fill = "Sample Group")

save(beta, meta, anno, file = "RData/902-ASXL1_Tcell_betas_norm.RData")
```

### Variable correlation matrix
```{r}
library(corrplot)
plt <- meta[, c("Disease_Status", # Sample groups
                "xMed", "yMed", "Sentrix_row", # Technical batch
                "predictedSex", # demographic variables
                "CD4mem", "CD4nv", "CD8mem", "CD8nv", "Treg", # cell type
                "CTP_PC1", "CTP_PC2", "CTP_PC3", "CTP_PC4", # Cell type PCs
                "Horvath", "Hannum", "Levine", "skinHorvath", "Wu") # DNAm age
            ] %>% as.data.frame()
plt$Disease_Status <- plt$Disease_Status %>% 
    gsub("Healthy control", 0, .) %>% 
    gsub("ASXL1 rescue", 1, .) %>% 
    gsub("ASXL1 variant", 2, .) %>% 
    as.numeric()
plt$predictedSex <- plt$predictedSex %>% 
    gsub("F", 0, .) %>% 
    gsub("M", 1, .) %>% 
    as.numeric()

# Calculate correlation statistics
cor.mat <- cor(plt)

# Calculate 
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(plt)
head(p.mat[, 1:5])

library(RColorBrewer)
corrplot(cor.mat, type="upper", order = "original", 
         col = brewer.pal(n = 8, name = "RdBu"), 
         tl.col = "black", tl.srt = 45,
         p.mat = p.mat, sig.level = 0.05, 
         pch.col = "gray", pch.cex = 2, diag = F)

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
corrplot(cor.mat, method = "color", col = col(200), 
         type = "upper", order = "original", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col = "black", tl.srt = 45, #Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = 0.05, 
         insig = "n", diag = F)
```


### Check DNAm clustering - Hierarchical and PCA

```{r}
# Heatmap
bt <- beta[sample(1:nrow(beta),50000), ]
pheatmap(bt, show_rownames = F)

# PCA
source("../../Functions/heatscreesimple.R")
PCA.C <- prcomp(beta)
meta_cat <- meta[, c("predictedSex", "Sample_Group")] 
colnames(meta_cat) <- c("Predicted_Sex", "Sample_Group")
meta_con <- meta[, c("Sentrix_row", "CTP_PC1", "CTP_PC2", "CTP_PC3", "CTP_PC4")] 
heatscreesimple(PCA.C$rotation, PCA.C$sdev^2, meta_cat, meta_con, 5) # Don't need to adjust for batch!

pcaObj <- PCA.C$rotation %>% as.data.frame() %>% cbind(., meta[, c("Sample_Group", "predictedSex")])
group.colors <- c("family control" = "#EBCB8BFF", "unrelated healthy control" = "#A3BE8CFF", "patient empty vector" ="#BF616AFF", "patient wild type" = "#B48EADFF")
ggplot(pcaObj, aes(PC1, PC2, color = Sample_Group, shape = predictedSex)) + 
    geom_point(size = 4) + 
    theme_bw() +
    scale_color_manual(values = group.colors)
```

### Correct for cell type - correct for flow CD8 proportion
Even though cell types are not in top PCs

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")

residuals <- t(apply(beta, 1, function(x){
    x <- as.numeric(x)
    residuals(summary(lm(x ~ CD8_perc_flow, data = meta)))
}))
colnames(residuals) <- colnames(beta)
adj.residuals <- residuals + matrix(apply(beta, 1, mean), nrow = nrow(residuals), ncol = ncol(residuals))
adj.residuals[adj.residuals <= 0] <- 0.0001 # convert any values that are less than or equal to zero to 0.0001
adj.residuals[adj.residuals > 1] <- 0.9999

save(adj.residuals, file = "RData/902-ASXL1_Tcell_betas_ct_adjusted.RData")
```

## Data analysis

### Check if the patient samples are outside the HC range

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")
load("RData/902-ASXL1_Tcell_betas_ct_adjusted.RData")

beta <- adj.residuals # if using cell type corrected betas

# Compared to IQR / SD range
meta$Disease_Status <- gsub(".*control", "Healthy control", meta$Sample_Group) %>% 
    gsub(".*vector", "ASXL1 variant", .) %>% 
    gsub(".*type", "ASXL1 rescue", .)

# Subset for patient and HCs
beta.pat <- beta[, "P_EV"]
beta.res <- beta[, "P_WT ASXL1"]
beta.ref <- beta[, meta$Disease_Status == "Healthy control"]

# Calculate the reference range
beta.refIQR <- apply(beta.ref, 1, function(x) {quantile(x, c(0.025, 0.25, 0.5, 0.75, 0.975))}) %>% t() %>% as.data.frame()
beta.refIQR$iqr <- beta.refIQR[, 4] - beta.refIQR[, 2]
beta.refIQR$beta.refIQRl <- beta.refIQR[, 2] - 1.5*beta.refIQR$iqr
beta.refIQR$beta.refIQRh <- beta.refIQR[, 4] + 1.5*beta.refIQR$iqr
beta.refSD <- apply(beta.ref, 1, sd)
beta.refM <- apply(beta.ref, 1, mean)

ASXL1.test <- cbind(beta.refIQR, beta.refSD, beta.refM, beta.pat, beta.res) %>% as.data.frame()
ASXL1.test$beta.refSD2l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*2)
ASXL1.test$beta.refSD2h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*2)
ASXL1.test$beta.refSD3l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*3)
ASXL1.test$beta.refSD3h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*3)
ASXL1.test$beta.refSD4l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*4)
ASXL1.test$beta.refSD4h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*4)
ASXL1.test$beta.refSD5l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*5)
ASXL1.test$beta.refSD5h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*5)

# Set empty variable for tests
ASXL1.test$IQR.test.pat <- NA
ASXL1.test$IQR.test.res <- NA
ASXL1.test$IQR2.test.pat <- NA
ASXL1.test$IQR2.test.res <- NA
ASXL1.test$SD2.test.pat <- NA
ASXL1.test$SD2.test.res <- NA
ASXL1.test$SD3.test.pat <- NA
ASXL1.test$SD3.test.res <- NA
ASXL1.test$SD4.test.pat <- NA
ASXL1.test$SD4.test.res <- NA
ASXL1.test$SD5.test.pat <- NA
ASXL1.test$SD5.test.res <- NA

for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "2.5%"] | 
       beta.pat[i] > ASXL1.test[i, "97.5%"]) {
        ASXL1.test$IQR.test.pat[i] <- "s"
    } else {
        ASXL1.test$IQR.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "2.5%"] | 
       beta.res[i] > ASXL1.test[i, "97.5%"]) {
        ASXL1.test$IQR.test.res[i] <- "s"
    } else {
        ASXL1.test$IQR.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refIQRl"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refIQRh"]) {
        ASXL1.test$IQR2.test.pat[i] <- "s"
    } else {
        ASXL1.test$IQR2.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refIQRl"] | 
       beta.res[i] > ASXL1.test[i, "beta.refIQRh"]) {
        ASXL1.test$IQR2.test.res[i] <- "s"
    } else {
        ASXL1.test$IQR2.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD2l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD2h"]) {
        ASXL1.test$SD2.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD2.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD2l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD2h"]) {
        ASXL1.test$SD2.test.res[i] <- "s"
    } else {
        ASXL1.test$SD2.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD3l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD3h"]) {
        ASXL1.test$SD3.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD3.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD3l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD3h"]) {
        ASXL1.test$SD3.test.res[i] <- "s"
    } else {
        ASXL1.test$SD3.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD4l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD4h"]) {
        ASXL1.test$SD4.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD4.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD4l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD4h"]) {
        ASXL1.test$SD4.test.res[i] <- "s"
    } else {
        ASXL1.test$SD4.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD5l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD5h"]) {
        ASXL1.test$SD5.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD5.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD5l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD5h"]) {
        ASXL1.test$SD5.test.res[i] <- "s"
    } else {
        ASXL1.test$SD5.test.res[i] <- "ns"
    }
}

sum(ASXL1.test$IQR.test.pat == "s") # 395147 / 358871
sum(ASXL1.test$IQR.test.res == "s") # 363057 / 221819
sum(ASXL1.test$IQR2.test.pat == "s") # 257476 / 92269
sum(ASXL1.test$IQR2.test.res == "s") # 210664 / 46893

hits_rescued <- rownames(ASXL1.test)[ASXL1.test$IQR2.test.pat == "s" & ASXL1.test$IQR2.test.res == "ns"] 
length(hits_rescued) # 151880
hits_not_rescued <- rownames(ASXL1.test)[ASXL1.test$IQR2.test.pat == "s" & ASXL1.test$IQR2.test.res == "s"] 
length(hits_not_rescued) # 132792

sum(ASXL1.test$SD2.test.pat == "s") # 264844 / 2766
sum(ASXL1.test$SD2.test.res == "s") # 216981 / 1333
sum(ASXL1.test$SD3.test.pat == "s") # 168067 / 0
sum(ASXL1.test$SD3.test.res == "s") # 106935 / 0
sum(ASXL1.test$SD4.test.pat == "s") # 106935 / 0
sum(ASXL1.test$SD4.test.res == "s") # 62515 / 0
sum(ASXL1.test$SD5.test.pat == "s") # 67239 / 0
sum(ASXL1.test$SD5.test.res == "s") # 36362 / 0

# Check for hyper / hypo methylation
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$beta.pat > ASXL1.test$beta.refM]) # 81
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$beta.pat < ASXL1.test$beta.refM]) # 2685
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.res == "s" & ASXL1.test$beta.res > ASXL1.test$beta.refM]) # 1209
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.res == "s" & ASXL1.test$beta.res < ASXL1.test$beta.refM]) # 124


hits_rescued <- rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$SD2.test.res == "ns"] 
length(hits_rescued) # 50311 / 2766
hits_not_rescued <- rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$SD2.test.res == "s"] 
length(hits_not_rescued) # 16928 / 0
hits_messed_up <- rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "ns" & ASXL1.test$SD2.test.res == "s"] 
length(hits_messed_up) # 19434 / 1333

saveRDS(ASXL1.test, file = "RData/903-ASXL1_Tcell_global_test.rds")
ASXL1.test.CC <- ASXL1.test
saveRDS(ASXL1.test.CC, file = "RData/903-ASXL1_Tcell_global_test_ct_adjusted.rds")

# hist(ASXL1.test$beta.refSD)
# hist(ASXL1.test$beta.refM)

# Make Heatmap
beta <- beta[, c("HC1", "HC2", "HC3", "Dad", "Mom", "Sister", "P_EV", "P_WT ASXL1")] 
plt <- beta[hits_rescued, ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
pheatmap(plt, # [sample(1:nrow(plt),50000),]
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 75k
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F)

plt <- beta[hits_not_rescued, ] 
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F)
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F)

plt <- beta[hits_messed_up, ] 
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F)
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F)
```

#### Explore reference range comparison results

##### Defining regions for DMR analysis
```{r}
anno <- readRDS("../../Reference/EPICv2_fdat.rds")
anno <- anno[!is.na(anno$MAPINFO), ]
anno <- anno[with(anno, order(CHR, MAPINFO)),]

# Region for finding DMR
anno$Mreg <- 1
reg <- 1
for (i in 2:nrow(anno)) {
    if (anno$MAPINFO[i] - anno$MAPINFO[i-1] > 1000) {
        reg <- reg + 1
    }
    anno$Mreg[i] <- reg
}

# Regions for gene region plotting
anno$Mreg_plt <- 1
reg <- 1
for (i in 2:nrow(anno)) {
    if (anno$MAPINFO[i] - anno$MAPINFO[i-1] > 10000) {
        reg <- reg + 1
    }
    anno$Mreg_plt[i] <- reg
}

rownames(anno) <- anno$IlmnID
saveRDS(anno, file = "../../Reference/EPICv2_fdat_Mreg.rds")

# anno$Mreg <- sapply(unique(anno$CHR), function(chr){
#     i <- 1
#     anno_chr <- anno[anno$CHR == chr, ] %>%
#         .[order(.$MAPINFO), ]
#     anno_chr$Mreg <- NA
#     apply(anno_chr, 1, function(cpg){
#         
#     })
# })

anno_v2 <- readRDS("../../Reference/EPICv2_fdat_Mreg.rds")
load("../../Reference/EPIC_fdat_Mreg.RData")
anno_v1 <- fdat_EPIC_Mreg


```

##### Map hits to annotation - plot DMRs

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")
ASXL1.test <- readRDS("RData/903-ASXL1_Tcell_global_test.rds")
anno <- readRDS("../../Reference/EPICv2_fdat_Mreg.rds")
source("../../Functions/plotmultigeneregion.R")
source("../../Functions/plotGeneRegion.R")

ASXL1.test.anno <- merge(ASXL1.test, anno[, c("CHR", "MAPINFO", "Mreg", "Mreg_plt", "UCSC_RefGene_Name", "GencodeCompV12_NAME")], by = 0)
rownames(ASXL1.test.anno) <- ASXL1.test.anno$Row.names

# Take the biggest DMRs
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s" & ASXL1.test.anno$SD5.test.res == "ns", "Mreg"]) %>% sort(decreasing = T) %>% .[.>3] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_rescued.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= 0.7] %>% 
    names(.) # At least 15% 

# Make table of hits
length(hits_rescued.dmr) #502 at Mreg size >= 5
View(ASXL1.test.anno[ASXL1.test.anno$Mreg %in% hits_rescued.dmr, ])

# ASXL1.test.dmr <- table(ASXL1.test.anno[test, "Mreg"]) %>% sort(decreasing = T) %>% .[.>=3] %>% names()
hits_rescued.dmr.gene <- sapply(hits_rescued.dmr, function(x) {
    test <- anno[anno$Mreg == x, "UCSC_RefGene_Name"] %>% 
               strsplit2(., ";") %>%
               as.vector() %>%
               unique()
    if (identical(test, character(0))) test <- ""
    if (length(test) > 1) {
        test <- test[test != ""]
        test <- paste0(test, collapse = ", ")
    }
    return(test)
}) 
dmr.genes <- do.call(c, hits_rescued.dmr.gene)
toString(shQuote(hits_rescued.dmr.gene))
genes <- c('LOC101927342', 'MAP4K4', 'MIR143HG, LOC728264', 'KCNB2', 'TMEM125', 'LOC400794', 'DISC1, TSNAX-DISC1', '', 'CACNA2D3', '', '', 'NXPH1', 'RNF19A', 'OR8D4', 'MTUS2', 'ARFRP1')
genes_plt <- genes
# If byvar  = "Mreg"
hits_rescued.dmr.geneanno <- anno[anno$Mreg %in% hits_rescued.dmr, ]
# If byvar  = "UCSC_RefGene_Name"
# hits_rescued.dmr.geneanno <- anno[grep(paste(genes_plt, collapse = "|"), anno$UCSC_RefGene_Name), ]

group.colors <- c("family control" = "#EBCB8BFF", "unrelated healthy control" = "#A3BE8CFF", "patient empty vector" ="#BF616AFF", "patient wild type" = "#B48EADFF")
mcolors <-  c("family control" = "#EBCB8BFF", "unrelated healthy control" = "gray", "patient empty vector" ="#BF616AFF", "patient wild type" = "#B48EADFF")
malpha <-  c("family control" = 0.3, "unrelated healthy control" = 0.3, "patient empty vector" = 1, "patient wild type" = 1)
plotmultigeneregion(bt = beta, # [, meta$Disease_Status == "Healthy Control" | rownames(meta) == "203077630141_R07C01"] 
                    plist = hits_rescued.dmr, #genes_plt
                    fdat = hits_rescued.dmr.geneanno,
                    byvar = "Mreg", #UCSC_RefGene_Name
                    colorvar = meta$Sample_Group, # [meta$Disease_Status == "Healthy Control" | rownames(meta) == "203077630141_R07C01"]
                    cscale = group.colors, 
                    ascale = malpha, 
                    title = genes_plt, 
                    hide.legend = T, 
                    nCol = 4) 

```

#### Enrichment analysis - ORA
Can only do ORA because no statistics is available

```{r}
# enrichment analysis with clusterProfiler
R.utils::setOption("clusterProfiler.download.method","auto")

# Define hits
dmr_size <- 2 # To be called a DMR, the region needs to have at least this many DMs
dmr_perc <- 0 # The hits need to encompass this percent of the region (to avoid very large regions with few hits)

# Rescued
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s" & ASXL1.test.anno$SD5.test.res == "ns", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_rescued.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% # At least 30% 
    names(.) 
genes_rescued <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_rescued.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""] # remove missing values

# The code for converting gene name to entrez ID if needed
# AnnotationDbi::select(org.Hs.eg.db,
#                       keys = .,
#                       columns = c("ENTREZID", "SYMBOL"),
#                       keytype = "SYMBOL") 

# Not rescued
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s" & ASXL1.test.anno$SD5.test.res == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_not_rescued.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_not_rescued <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_not_rescued.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique()%>%
    .[. != ""]

# Messed up by WT ASXL1
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "ns" & ASXL1.test.anno$SD5.test.res == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_messed_up.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_messed_up <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_messed_up.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# EV
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_EV.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_EV <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_EV.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# WT ASXL1
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.res == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_WT.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_WT <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_WT.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# Background genes measured on the array
genes_universe <- ASXL1.test.anno$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""] 

# Hallmark enrichment - want to check IL2-STAT5 pathway
gs_hallmark <- msigdbr(species = "human", category = "H")
msigdbr_t2g <- gs_hallmark %>% 
    dplyr::distinct(gs_name, gene_symbol) %>% 
    as.data.frame 
# msigdbr_t2g = h_gene_sets %>% dplyr::distinct(gs_name, entrez_gene) %>% as.data.frame()
# enricher(gene = genes_rescued$ENTREZID, TERM2GENE = msigdbr_t2g, universe = genes_universe$ENTREZID)
(pathway_rescued <- enricher(gene = genes_rescued, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_HEDGEHOG_SIGNALING"
(pathway_not_rescued <- enricher(gene = genes_not_rescued, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_ESTROGEN_RESPONSE_LATE" "HALLMARK_MYOGENESIS"
(pathway_messed_up <- enricher(gene = genes_messed_up, TERM2GENE = msigdbr_t2g, universe = genes_universe))
(pathway_EV <- enricher(gene = genes_EV, TERM2GENE = msigdbr_t2g, universe = genes_universe)) # "HALLMARK_MYOGENESIS" "HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_ANGIOGENESIS" "HALLMARK_HEDGEHOG_SIGNALING" "HALLMARK_COAGULATION" "HALLMARK_ESTROGEN_RESPONSE_LATE" "HALLMARK_APICAL_JUNCTION"
(pathway_WT <- enricher(gene = genes_WT, TERM2GENE = msigdbr_t2g, universe = genes_universe)) # "HALLMARK_UV_RESPONSE_DN" "HALLMARK_ANDROGEN_RESPONSE"

gs_all <- msigdbr(species = "human")
gs_immune <- gs_all %>%
    dplyr::filter(gs_cat == "C7" & gs_subcat == "IMMUNESIGDB") %>%
    head()
msigdbr_t2g <- immune_gs %>% 
    dplyr::distinct(gs_name, gene_symbol) %>% 
    as.data.frame 
(pathway_rescued <- enricher(gene = genes_rescued, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_HEDGEHOG_SIGNALING"
#  [1] "GSE10147_IL3_VS_IL3_AND_HIVP17_STIM_PDC_DN"                                  "GSE22886_IL2_VS_IL15_STIM_NKCELL_UP"                                         "GSE21380_TFH_VS_GERMINAL_CENTER_TFH_CD4_TCELL_UP"      
#  [4] "GSE10239_MEMORY_VS_KLRG1HIGH_EFF_CD8_TCELL_UP"                               "GSE9946_IMMATURE_VS_MATURE_STIMULATORY_DC_DN"                                "GSE45739_UNSTIM_VS_ACD3_ACD28_STIM_NRAS_KO_CD4_TCELL_DN"  
#  [7] "GSE19825_NAIVE_VS_IL2RAHIGH_DAY3_EFF_CD8_TCELL_UP"                           "GSE29164_DAY3_VS_DAY7_CD8_TCELL_AND_IL12_TREATED_MELANOMA_DN"                "GSE360_DC_VS_MAC_T_GONDII_UP"                             
# [10] "GSE21379_WT_VS_SAP_KO_TFH_CD4_TCELL_UP"                                      "GSE40666_UNTREATED_VS_IFNA_STIM_EFFECTOR_CD8_TCELL_90MIN_UP"                 "GSE3203_WT_VS_IFNAR1_KO_INFLUENZA_INFECTED_LN_BCELL_DN"   
# [13] "GSE2405_HEAT_KILLED_LYSATE_VS_LIVE_A_PHAGOCYTOPHILUM_STIM_NEUTROPHIL_24H_DN" "GSE7568_CTRL_VS_3H_TGFB_TREATED_MACROPHAGES_WITH_IL4_AND_DEXAMETHASONE_UP"   "GSE13887_ACT_CD4_VS_NO_TREATED_CD4_TCELL_UP"           
# [16] "GSE2405_0H_VS_1.5H_A_PHAGOCYTOPHILUM_STIM_NEUTROPHIL_UP"

ego <- enrichGO(gene          = genes_rescued,
                universe      = genes_universe,
                OrgDb         = org.Hs.eg.db,
                keyType       = "SYMBOL", #idType(OrgDb) for available keyTypes
                ont           = "ALL",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                readable      = TRUE)
head(ego)


# ann <- getAnnotation(IlluminaHumanMethylationEPICv2anno.20a1.hg38)

# GO pathways
GE_EV.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s"],
                   rownames(ASXL1.test.anno), 
                   "GO", "EPIC", T, anno = anno)
GE_EV.go[GE_EV.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()
GE_WT.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.res == "s"],
                   rownames(ASXL1.test.anno), 
                   "GO", "EPIC", T, anno = anno)
GE_WT.go[GE_WT.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ]
GE_rescued.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "ns"],
                        rownames(ASXL1.test.anno), 
                        "GO", "EPIC", T, anno = anno)
GE_rescued.go[GE_rescued.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()
GE_not_rescued.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "s"],
                            rownames(ASXL1.test.anno), 
                            "GO", "EPIC", T, anno = anno)
GE_not_rescued.go[GE_not_rescued.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()
GE_messed_up.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "ns" & ASXL1.test.anno$SD4.test.res == "s"],
                          rownames(ASXL1.test.anno), 
                          "GO", "EPIC", T, anno = anno)
GE_messed_up.go[GE_messed_up.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()

# KEGG
GE_EV.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s"],
                     rownames(ASXL1.test.anno),
                     "KEGG", "EPIC", T, anno = anno)
GE_EV.kegg[order(GE_EV.kegg$FDR), ]
GE_WT.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.res == "s"],
                   rownames(ASXL1.test.anno), 
                   "KEGG", "EPIC", T, anno = anno)
GE_WT.kegg[order(GE_WT.kegg$FDR), ]
GE_rescued.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "ns"],
                        rownames(ASXL1.test.anno), 
                        "KEGG", "EPIC", T, anno = anno)
GE_rescued.kegg[order(GE_rescued.kegg$FDR), ]
GE_not_rescued.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "s"],
                            rownames(ASXL1.test.anno), 
                            "KEGG", "EPIC", T, anno = anno)
GE_not_rescued.kegg[order(GE_not_rescued.kegg$FDR), ]
GE_messed_up.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "ns" & ASXL1.test.anno$SD4.test.res == "s"],
                          rownames(ASXL1.test.anno), 
                          "KEGG", "450K", T, anno = anno)
GE_messed_up.kegg[GE_messed_up.kegg$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ]
GE_messed_up.kegg[order(GE_messed_up.kegg$FDR), ]

save(GE_EV.go, GE_WT.go, GE_rescued.go, GE_not_rescued.go, GE_messed_up.go, 
     # GE_EV.kegg, GE_WT.kegg, GE_rescued.kegg, GE_not_rescued.kegg, GE_messed_up.kegg, 
     file = "RData/904-ASXL1_Tcell_HCreference_ORA_Enrichment.RData")
```



### Permutation test

```{r}
# Compared to IQR / SD range
load("RData/902-ASXL1_Tcell_betas_norm.RData")

# Set progress bar
set.seed(1234)
permTest <- function(cpg, group, group_var, n) {
    g <- unique(group)
    m0 <- mean(cpg[group == group_var]) # find the average DNAm level for group_var (in this case patient sample)
    m1 <- sapply(n, function(x) {
        ngroup <- sample(group, length(group)) # random shuffling of labels
        mean(cpg[ngroup == group_var]) # find the average DNAm level for randomly labelled samples
    })
    out <- c(sum(m0>=m1), sum(m0<=m1))
    return(out)
}
# permTest2 <- function(cpg, group, n) {
#     g <- unique(group)
#     test <- sapply(n, function(x) {
#         ngroup <- sample(group, length(group)) # random shuffling of labels
#         m <- mean(cpg[ngroup == group_var])
#         ipr <- quantile(cpg[ngroup == "Healthy control"], c(0.025, 0.975))
#         return(c(mean = m, ipr))
#     }) %>% t() %>% as.data.frame()
#     out <- sum(test$mean < test$"2.5%" | test$mean > test$"97.5%")
#     return(out)
# } This test makes no sense currently 
N <- 1000
cl <- 10

# Check patient vs HC - sign test
beta.t <- beta[, colnames(beta) != "P_WT ASXL1"]
meta.t <- meta[colnames(beta.t), ]
permOut.EV <- pbapply(beta.t, 1, function(x) permTest(x, meta.t$Disease_Status, "ASXL1 variant", 1:N), cl = cl) %>% t() %>% as.data.frame()
permOut.EV <- permOut.EV/N
colnames(permOut.EV) <- c("Hypo_pval", "Hyper_pval")
permOut.EV$Hypo_qval <- p.adjust(permOut.EV$Hypo_pval)
permOut.EV$Hyper_qval <- p.adjust(permOut.EV$Hyper_pval)

# Check rescue vs HC - sign test
beta.t <- beta[, colnames(beta) != "P_EV"]
meta.t <- meta[colnames(beta.t), ]
permOut.WT <- pbapply(beta.t, 1, function(x) permTest(x, meta.t$Disease_Status, "ASXL1 rescue", 1:N), cl = cl) %>% t() %>% as.data.frame()
permOut.WT <- permOut.WT/N
colnames(permOut.WT) <- c("Hypo_pval", "Hyper_pval")
permOut.WT$Hypo_qval <- p.adjust(permOut.WT$Hypo_pval)
permOut.WT$Hyper_qval <- p.adjust(permOut.WT$Hyper_pval)

save(permOut.EV, permOut.WT, file = "RData/903-ASXL1_Tcell_permutation_sign_test.RData")

# # Check patient vs HC - iqr test
# beta.t <- beta[, colnames(beta) != "P_WT ASXL1"] 
# meta.t <- meta[colnames(beta.t), ]
# permOut2.pat <- pbapply(beta.t, 1, function(x) permTest2(x, meta.t$Disease_Status, "ASXL1 variant", 1:N), cl = cl) %>% t()
# permOut2.pat <- as.data.frame(permOut2.pat/N)
# colnames(permOut2.pat) <- c("pval")
# permOut2.pat$Hypo_qval <- p.adjust(permOut2.pat$Hypo_pval)
# permOut2.pat$Hyper_qval <- p.adjust(permOut2.pat$Hyper_pval)
# 
# # Check rescue vs HC - iqr test
# beta.t <- beta[, colnames(beta) != "P_EV"]
# meta.t <- meta[colnames(beta.t), ]
# permOut2.res <- pbapply(beta.t, 1, function(x) permTest2(x, meta.t$Disease_Status, "ASXL1 rescue", 1:N), cl = cl) %>% t() %>% as.data.frame(./N)
# colnames(permOut2.res) <- c("Hypo_pval", "Hyper_pval")
# permOut2.res$Hypo_qval <- p.adjust(permOut2.res$Hypo_pval)
# permOut2.res$Hyper_qval <- p.adjust(permOut2.res$Hyper_pval)
# 
# save(permOut2.pat, permOut2.res, file = "RData/904-ASXL1_Tcell_permutation_iqr_test.RData")

# Check overlap
cutoff <- 1/7 # Likelihood for patient sample to get picked
test.hyper <- intersect(rownames(permOut.EV)[permOut.EV$Hyper_qval < cutoff], rownames(permOut.WT)[permOut.WT$Hyper_pval < cutoff]) # 77 vs 0
test.hypo <- intersect(rownames(permOut.EV)[permOut.EV$Hypo_pval < cutoff], rownames(permOut.WT)[permOut.WT$Hypo_pval < cutoff]) # 207 vs 0
# test2.hyper <- intersect(rownames(permOut2.pat)[permOut2.pat$Hyper_pval < cutoff], rownames(permOut2.res)[permOut2.res$Hyper_pval < cutoff]) # 28 / 185
# test2.hypo <- intersect(rownames(permOut2.pat)[permOut2.pat$Hypo_pval < cutoff], rownames(permOut2.res)[permOut2.res$Hypo_pval < cutoff]) # 28 / 185
length(rownames(permOut.EV)[permOut.EV$Hyper_pval < cutoff]) # 48515
length(rownames(permOut.EV)[permOut.EV$Hypo_pval < cutoff]) # 137860
length(rownames(permOut.WT)[permOut.WT$Hyper_pval < cutoff]) # 94067
length(rownames(permOut.WT)[permOut.WT$Hypo_pval < cutoff]) # 76163
length(intersect(rownames(permOut2.pat)[permOut2.pat$pval < cutoff], rownames(permOut2.res)[permOut2.res$pval < cutoff]))

# Make heatmap
plt.hyper <- beta[rownames(permOut.EV)[permOut.EV$Hyper_pval < cutoff], ] %>% 
    .[.]
plt.hypo <- beta[rownames(permOut.EV)[permOut.EV$Hypo_pval < cutoff], ]
pheatmap(plt.hyper, show_rownames = F, scale = "row", treeheight_row = 0)
pheatmap(plt.hypo[sample(1:nrow(plt.hypo), 50000), ], show_rownames = F, scale = "row", treeheight_row = 0)

plt.hyper <- beta[rownames(permOut.WT)[permOut.WT$Hyper_pval < cutoff], ]
plt.hypo <- beta[rownames(permOut.WT)[permOut.WT$Hypo_pval < cutoff], ]
pheatmap(plt.hyper[sample(1:nrow(plt.hypo), 50000), ], show_rownames = F, scale = "row", treeheight_row = 0)
pheatmap(plt.hypo[sample(1:nrow(plt.hypo), 50000), ], show_rownames = F, scale = "row", treeheight_row = 0)

pheatmap(rbind(plt.hyper, plt.hypo), show_rownames = F, scale = "row")
```

#### Enrichment Analysis - preranked GSEA

```{r}
# Genes involved in the hits

# Enrichment analysis
```

### Limma

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData.RData")
# load("RData/902-ASXL1_Tcell_betas_ct_adjusted.RData")

# beta <- adj.residuals

# Check patient vs HC - Limma
beta.t <- beta[, colnames(beta) != "P_WT ASXL1"]
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- factor(meta.t$Disease_Status, levels = c("Healthy control", "ASXL1 variant"))

design <- model.matrix(~Disease_Status + predictedSex + CD8_perc_flow, data = meta.t)
fit <- lmFit(beta.t, design)
fit <- eBayes(fit)
limmaOut <- topTable(fit, coef = 2, adjust = "BH", number = nrow(beta.t))
dim(limmaOut.EV <- merge(limmaOut, anno[, c("CHR", "MAPINFO", "Mreg", "Mreg_plt", "UCSC_RefGene_Name", "GencodeCompV12_NAME")], by = 0) %>%
    .[order(.$P.Value, decreasing = F), ])
rownames(limmaOut.EV) <- as.character(limmaOut.EV$Row.names)
limmaOut.EV_up <- limmaOut.EV[limmaOut.EV$logFC > 0, ]
limmaOut.EV_down <- limmaOut.EV[limmaOut.EV$logFC < 0, ]

# Check WT ASXL1 vs HC - Limma
beta.t <- beta[, colnames(beta) != "P_EV"]
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- factor(meta.t$Disease_Status, levels = c("Healthy control", "ASXL1 rescue"))

design <- model.matrix(~Disease_Status + predictedSex + CD8_perc_flow, data = meta.t)
fit <- lmFit(beta.t, design)
fit <- eBayes(fit)
limmaOut <- topTable(fit, coef = 2, adjust = "BH", number = nrow(beta.t))
dim(limmaOut.WT <- merge(limmaOut, anno[, c("CHR", "MAPINFO", "Mreg", "Mreg_plt", "UCSC_RefGene_Name", "GencodeCompV12_NAME")], by = 0) %>%
    .[order(.$P.Value, decreasing = F), ])
rownames(limmaOut.WT) <- as.character(limmaOut.WT$Row.names)
limmaOut.WT_up <- limmaOut.WT[limmaOut.WT$logFC > 0, ] #5012
limmaOut.WT_down <- limmaOut.WT[limmaOut.WT$logFC < 0, ] #1444

# Check overlap between EV and WT
length(intersect(limmaOut.EV_up$Row.names[limmaOut.EV_up$adj.P.Val < 0.05], limmaOut.WT_up$Row.names[limmaOut.WT_up$adj.P.Val < 0.05])) #3196
length(intersect(limmaOut.EV_down$Row.names[limmaOut.EV_down$adj.P.Val < 0.05], limmaOut.WT_down$Row.names[limmaOut.WT_down$adj.P.Val < 0.05])) #1299
limmaOut.shared <- c(intersect(limmaOut.EV_up$Row.names, limmaOut.WT_up$Row.names), 
                  intersect(limmaOut.EV_down$Row.names, limmaOut.WT_down$Row.names))

# Save results
save(limmaOut.EV, limmaOut.WT, file = "RData/903-ASXL1_Tcell_limma_test.RData")
save(limmaOut.EV, limmaOut.WT, file = "RData/903-ASXL1_Tcell_limma_test_ct_adjusted.RData")
```

#### Plotting Limma's hits

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")

beta <- adj.residuals

beta <- beta[, c("HC1", "HC2", "HC3", "Dad", "Mom", "Sister", "P_EV", "P_WT ASXL1")] 

cutoff <- 0.2
limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff, ]
limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff, ]

plt <- beta[rownames(limmaHits.EV), ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
pheatmap(plt[sample(1:nrow(plt),50000),], # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt[sample(1:nrow(plt),50000),], # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
plt <- beta[rownames(limmaHits.WT), ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering

plt <- beta[limmaOut.shared, ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
```


#### Examine overlap of EV and Rescue

```{r}
load("RData/903-ASXL1_Tcell_limma_test.RData")
load("RData/903-ASXL1_Tcell_limma_test_ct_adjusted.RData")
load("../../Reference/EPIC_fdat_Mreg.RData")

cutoff <- 0.05

# Subset to hits
limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff, ]
limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff, ]

# refHits.EV <- refOut[refOut$SD5.test.pat == "s", ]
# refHits.WT <- refOut[refOut$SD5.test.res == "s", ]
# permHits.EV <- permOut.EV[permOut.EV$Hypo_pval < 1/7 | permOut.EV$Hyper_pval < 1/7, ]
# permHits.WT <- permOut.WT[permOut.WT$Hypo_pval < 1/7 | permOut.WT$Hyper_pval < 1/7, ]

# Make Venn Diagram
group.colors <- c("EV" ="#550307FF", "WT" = "#4B644BFF")
limmaHits.O <- list(EV = rownames(limmaHits.EV),
                    WT = rownames(limmaHits.WT))

ggvenn(limmaHits.O,
       fill_color = c("#550307FF", "#4B644BFF"),
       stroke_size = 0.5, 
       set_name_size = 4, 
       fill_alpha = 0.7, 
       auto_scale = T)


```


#### Enrichment analysis on Limma's result

```{r}
load("RData/903-ASXL1_Tcell_limma_test_ct_adjusted.RData")

cutoff <- 0.05
limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff, ]
limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff, ]


genes_EV <- limmaHits.EV$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_EV_up <- limmaHits.EV$UCSC_RefGene_Name[limmaHits.EV$logFC > 0] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_EV_down <- limmaHits.EV$UCSC_RefGene_Name[limmaHits.EV$logFC < 0] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

genes_WT <- limmaOut.WT$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_WT_up <- limmaOut.WT_up$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_WT_down <- limmaOut.WT_down$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# Background genes measured on the array
genes_universe <- anno$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""] 

# Hallmark enrichment - want to check IL2-STAT5 pathway
h_gene_sets <- msigdbr(species = "human", category = "H")
msigdbr_t2g <- h_gene_sets %>% 
    dplyr::distinct(gs_name, gene_symbol) %>% 
    as.data.frame 
(pathway_EV <- enricher(gene = genes_EV, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION" "HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_KRAS_SIGNALING_DN" "HALLMARK_HEDGEHOG_SIGNALING" "HALLMARK_COAGULATION" "HALLMARK_NOTCH_SIGNALING" 
(pathway_EV_up <- enricher(gene = genes_EV_up, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_KRAS_SIGNALING_DN" "HALLMARK_APICAL_JUNCTION"                   "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_WNT_BETA_CATENIN_SIGNALING" "HALLMARK_ANGIOGENESIS" "HALLMARK_UV_RESPONSE_DN" "HALLMARK_ESTROGEN_RESPONSE_LATE" "HALLMARK_NOTCH_SIGNALING"
(pathway_EV_down <- enricher(gene = genes_EV_down, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_COAGULATION" "HALLMARK_APICAL_SURFACE"

(pathway_WT <- enricher(gene = genes_WT, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #  "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION"
(pathway_WT_up <- enricher(gene = genes_WT_up, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_UV_RESPONSE_DN"
(pathway_WT_down <- enricher(gene = genes_EV_down, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS"  "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_COAGULATION" "HALLMARK_APICAL_SURFACE"

# Plot enrichment
pathway_EV <- pathway_EV@result
pathway_EV$log10Padj <- log10(pathway_EV$p.adjust)*-1
ggplot(pathway_EV[pathway_EV$p.adjust < 0.05, ], aes(reorder(ID, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "")
pathway_WT <- pathway_WT@result
pathway_WT$log10Padj <- log10(pathway_WT$p.adjust)*-1
ggplot(pathway_WT[pathway_WT$p.adjust < 0.05, ], aes(reorder(ID, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "")
```

##### Preranked GSEA - fgsea

```{r}
# Preranked GSEA
# h_gene_sets_fgsea <- lapply(h_gene_sets$)
limmaRank.EV <- limmaOut.EV$t
names(limmaRank.EV) <- as.character(limmaOut.EV$Row.names)
```

##### GO enrichment - missMethyl

```{r}
# missMethyl GO enrichment
GE_EV.go <- gometh(as.character(limmaOut.EV$Row.names),
                   as.character(rownames(beta)), 
                   "GO", "EPIC", T, anno = anno)
plt <- GE_EV.go %>% .[order(.$P.DE), ]
head(plt)
plt$log10Padj <- log10(plt$FDR)*-1
ggplot(plt[1:20, ], aes(reorder(TERM, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "GO Gene Set Enrichment")

GE_WT.go <- gometh(as.character(limmaOut.WT$Row.names),
                   as.character(rownames(beta)), 
                   "GO", "EPIC", T, anno = anno)
plt <- GE_WT.go %>% .[order(.$P.DE), ]

plt$log10Padj <- log10(plt$FDR)*-1
ggplot(plt[1:20, ], aes(reorder(TERM, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "GO Gene Set Enrichment")
```

##### ChromHMM enrichment - missMethyl

```{r}
load("RData/902-ASXL1_Tcell_betas_norm.RData")
load("RData/903-ASXL1_Tcell_limma_test.RData")

### ChromHMM (thank you Nicole for all the code and creating the annotation file)
load("../../Reference/EPIC_Anno_ChromeHMM.RData")
Chrom_df <- EPIC_Anno_ChromeHMM[rownames(beta), c("Name", "E034_TCells_State")]
colnames(Chrom_df) <- c("Probe_ID", "region")
 
ChromHMMset <- lapply(unique(Chrom_df$region), function(x){
    cpgs <- Chrom_df$Probe_ID[Chrom_df$region == x]
    id <- getMappedEntrezIDs(cpgs, array.type = "EPIC", anno = anno)
    return(id$sig.eg)
})
names(ChromHMMset) <- unique(Chrom_df$region)

cutoff <- 0.05
pathChromHMM.EV <- gsameth(sig.cpg = rownames(limmaOut.EV)[limmaOut.EV$adj.P.Val <= cutoff], 
                           all.cpg = rownames(limmaOut.EV), 
                           collection = ChromHMMset, 
                           array.type = "EPIC", 
                           anno = anno) %>% .[order(.$FDR), ]
pathChromHMM.EV$Term <- rownames(pathChromHMM.EV) %>% 
    gsub("1_TssA", "Active TSS", .) %>%
    gsub("2_TssFlnk", "Flanking TSS", .) %>% 
    gsub("3_TssFlnkU", "Flanking TSS Upstream", .) %>% 
    gsub("4_TssFlnkD", "Flanking TSS Downstream", .) %>% 
    gsub("5_Tx", "Strong Transcription", .) %>% 
    gsub("6_TxWk", "Weak Transcription", .) %>% 
    gsub("7_EnhG1", "Genic Enhancer 1", .) %>% 
    gsub("8_EnhG2", "Genic Enhancer 2", .) %>% 
    gsub("9_EnhA1", "Active Enhancer 1", .) %>% 
    gsub("10_EnhA2", "Active Enhancer 2", .) %>% 
    gsub("11_EnhWk", "Weak Enhancer", .) %>% 
    gsub("12_ZNF/Rpts", "ZNF genes & repeats", .) %>% 
    gsub("13_Het", "Heterochromatin", .) %>% 
    gsub("14_TssBiv", "Bivalent/Poised TSS", .) %>% 
    gsub("15_EnhBiv", "Bivalent Enhancer", .) %>% 
    gsub("16_ReprPC", "Repressed PolyComb", .) %>% 
    gsub("17_ReprPCWk", "Weak Repressed PolyComb", .) %>% 
    gsub("18_Quies", "Quiescent/Low", .) 
pathChromHMM.EV$log10Padj <- log10(pathChromHMM.EV$FDR)*-1


pathChromHMM.WT <- gsameth(sig.cpg = rownames(limmaOut.WT)[limmaOut.WT$adj.P.Val <= cutoff], 
                           all.cpg = rownames(limmaOut.WT), 
                           collection = ChromHMMset, 
                           array.type = "EPIC", 
                           anno = anno) %>% .[order(.$FDR), ]
pathChromHMM.WT$Term <- rownames(pathChromHMM.WT) %>% 
    gsub("1_TssA", "Active TSS", .) %>%
    gsub("2_TssFlnk", "Flanking TSS", .) %>% 
    gsub("3_TssFlnkU", "Flanking TSS Upstream", .) %>% 
    gsub("4_TssFlnkD", "Flanking TSS Downstream", .) %>% 
    gsub("5_Tx", "Strong Transcription", .) %>% 
    gsub("6_TxWk", "Weak Transcription", .) %>% 
    gsub("7_EnhG1", "Genic Enhancer 1", .) %>% 
    gsub("8_EnhG2", "Genic Enhancer 2", .) %>% 
    gsub("9_EnhA1", "Active Enhancer 1", .) %>% 
    gsub("10_EnhA2", "Active Enhancer 2", .) %>% 
    gsub("11_EnhWk", "Weak Enhancer", .) %>% 
    gsub("12_ZNF/Rpts", "ZNF genes & repeats", .) %>% 
    gsub("13_Het", "Heterochromatin", .) %>% 
    gsub("14_TssBiv", "Bivalent/Poised TSS", .) %>% 
    gsub("15_EnhBiv", "Bivalent Enhancer", .) %>% 
    gsub("16_ReprPC", "Repressed PolyComb", .) %>% 
    gsub("17_ReprPCWk", "Weak Repressed PolyComb", .) %>% 
    gsub("18_Quies", "Quiescent/Low", .) 
pathChromHMM.WT$log10Padj <- log10(pathChromHMM.WT$FDR)*-1

plt <- pathChromHMM.WT
ggplot(plt, aes(reorder(Term, log10Padj), log10Padj)) + 
    geom_bar(stat = "identity") + 
    labs(y = "Adjusted P-value (-log10)", x = "ChromHMM 18 States Annotation in T-cells") + 
    geom_hline(yintercept = log10(0.01)*-1, linetype = 'dashed', color = "gray") +
    coord_flip() + 
    theme_bw() + 
    theme(text = element_text(size = 13)) + 
    ylim(0, 180)


pathChromHMM.EV$Term <- factor(pathChromHMM.EV$Term, levels = pathChromHMM.EV$Term[order(pathChromHMM.EV$log10Padj, decreasing = F)])
pathChromHMM.WT$Term <- factor(pathChromHMM.WT$Term, levels = pathChromHMM.EV$Term[order(pathChromHMM.EV$log10Padj, decreasing = F)])
# Plot the barplots together
# group.colors <- c("EV" ="#550307FF", "WT" = "#4B644BFF")
ggplot(mapping = aes(Term, log10Padj)) +
    geom_bar(data = pathChromHMM.EV, width = 0.8, stat = 'identity', fill = "#550307FF", alpha = 0.8) +
    geom_bar(data = pathChromHMM.WT, width = 0.8, stat = 'identity', fill = "#4B644BFF", alpha = 0.8) +
    # scale_y_continuous(expand = c(0, 0)) + 
    labs(y = "Adjusted P-value (-log10)", x = "ChromHMM 18 States Annotation in T-cells") + 
    geom_hline(yintercept = log10(0.01)*-1, linetype = 'dashed', color = "gray") +
    coord_flip() + 
    theme_bw() + 
    theme(text = element_text(size = 13)) + 
    ylim(0, 180)
```


### Examine overlap

```{r}
refOut <- readRDS("RData/903-ASXL1_Tcell_global_test.rds")
load("RData/903-ASXL1_Tcell_permutation_sign_test.RData")
load("RData/903-ASXL1_Tcell_limma_test.RData")

# Subset to hits
limmaHits.EV <- limmaOut.EV
limmaHits.WT <- limmaOut.WT
refHits.EV <- refOut[refOut$SD5.test.pat == "s", ]
refHits.WT <- refOut[refOut$SD5.test.res == "s", ]
permHits.EV <- permOut.EV[permOut.EV$Hypo_pval < 1/7 | permOut.EV$Hyper_pval < 1/7, ]
permHits.WT <- permOut.WT[permOut.WT$Hypo_pval < 1/7 | permOut.WT$Hyper_pval < 1/7, ]

# Make Venn Diagram
allHits.EV <- list(Outlier_test = rownames(refHits.EV),
                   Permutation_test = rownames(permHits.EV),
                   Limma_test = as.character(limmaHits.EV$Row.names))
allHits.WT <- list(Outlier_test = rownames(refHits.WT),
                   Permutation_test = rownames(permHits.WT),
                   Limma_test = as.character(limmaHits.WT$Row.names))

plot(euler(allHits.EV, shape = "ellipse"), quantities = TRUE)
plot(euler(allHits.WT, shape = "ellipse"), quantities = TRUE)

ggvenn(allHits.EV,
       fill_color = c("#7890A8", "#A8A8A8", "#6A7E4F"),
       stroke_size = 0.5, 
       set_name_size = 4, 
       fill_alpha = 0.7)

ggvenn(allHits.WT,
       fill_color = c("#7890A8", "#A8A8A8", "#6A7E4F"),
       stroke_size = 0.5, 
       set_name_size = 4, 
       fill_alpha = 0.7)
```


# Load new T cell data - N = 3 (load all 4 together)

## Preprocessing

Try to keep the preprocessing steps similar to the whole blood analysis
- Sample / probe QC
- Funnorm
- 

#### Reading IDATs

```{bash}
cd /mnt/cifs/maggie.fu/fs/KoborLab/raw_data/BRAINSTORM-KoborArchive2014March/RAW Data - DNA methylation/RAW data - EPIC methylation/2023/Turvey_May2023
scp -r * /mnt/scratch/KoborLab/Personal_Folders/mfu/Projects/ASXL1/raw/
cd /mnt/scratch/KoborLab/Personal_Folders/mfu/Projects/ASXL1/raw/207049890023/
mv *.idat ../
cd ../207049890067/
mv *.idat ../
rm -r 207049890023
rm -r 207049890067
```

```{r}
rawDir <- "raw"
targets <- read.metharray.sheet(rawDir)
RGset <- read.metharray.exp(base = rawDir, targets = targets, extended = T, recursive = T)
pheno <- pData(RGset) %>% as.data.frame()

# reassign the annotation so that the minfi functions getBeta(), preprocessRaw() and others like preprocessNoob() will work
annotation(RGset)["array"] <- "IlluminaHumanMethylationEPICv2"
annotation(RGset)["annotation"] <- "20a1.hg38"
(manifest <- getManifest(RGset))

saveRDS(RGset, file = "RData/905-ASXL1_Tcell_RGset_n3.rds")
saveRDS(RGset, file = "RData/905-ASXL1_Tcell_RGset_t1_t2.rds")
```

### Normalization

```{r}
RGset <- readRDS("RData/905-ASXL1_Tcell_RGset_n3.rds")
RGset <- readRDS("RData/905-ASXL1_Tcell_RGset_t1_t2.rds")

# anno <- readRDS("/mnt/scratch/KoborLab/Personal_Folders/mfu/Reference/EPICv2_fdat.rds")
anno <- readRDS("~/shared_coding_resource/EPIC_V2_fdat.rds")
anno <- anno[!duplicated(anno$NAME), ]
rownames(anno) <- anno$NAME
```

### Extracting / labeling meta data

```{r}
GRset <- preprocessFunnorm(RGset)
meta <- pData(GRset) %>% as.data.frame()

# Relabel things
meta$Sample_Name <- gsub("sister|SIS", "Sister", meta$Sample_Name) %>%
    gsub("DAD", "Dad", .) %>%
    gsub("MOM|mom", "Mom", .) %>%
    gsub("P_WT ASXL1", "R", .) %>%
    gsub("P_EU", "P", .)
meta$Sample_Group <- gsub("Sister|Mom|Dad", "family control", meta$Sample_Name) %>% 
    gsub("HC.*", "unrelated healthy control", .) %>% 
    gsub("P.*", "patient_EV", .) %>%
    gsub("R.*", "patient_WT", .)
meta$Time_Point <- c(rep("T2", 12), rep("T1", 8))
meta$Basename <- rownames(meta)
meta$Sentrix_Row <- gsub("C.*", "", meta$Array) %>% gsub("R", "", .) %>% as.integer()

# Mom and Dad got switched again
meta$Sample_Name[meta$Sample_Name == "Mom"] <- "Dad2"
meta$Sample_Name[meta$Sample_Name == "Dad"] <- "Mom"
meta$Sample_Name[meta$Sample_Name == "Dad2"] <- "Dad"

meta$Disease_Status <- gsub(".*control", "HC_EV", meta$Sample_Group) %>% 
    gsub("patient_EV", "Patient_EV", .) %>% 
    gsub("patient_WT", "Patient_WT", .)

meta$Age <- c(23, 15, 15, 21, 15, 74, 15, 18, 58, 15, 22, 15, 18, 21, 74, 23, 15, 15, 58, 22)

rownames(meta) <- paste0(meta$Sample_Name, "_", meta$Time_Point)

flow_ct_t2 <- read.csv("CD4-CD8 proportions.csv")
flow_ct_t2 <- rbind(flow_ct_t2, flow_ct_t2[c(6, 7, 6, 7), ])
rownames(flow_ct_t2) <- c("Dad_T2", "HC2_T2", "HC1_T2", "HC3_T2", "Mom_T2", "P1_T2", "R1_T2", "Sister_T2", "P2_T2", "R2_T2", "P3_T2", "R3_T2")
flow_ct_t1 <- read.csv("CD4-CD8 proportions first transduction.csv")
rownames(flow_ct_t1) <- c("Dad_T1", "HC2_T1", "HC3_T1", "HC1_T1", "Mom_T1", "P_T1", "R_T1", "Sister_T1")
flow_ct <- rbind(flow_ct_t1, flow_ct_t2)

meta$CD4_perc_flow <- flow_ct[rownames(meta), 2]
meta$CD8_perc_flow <- flow_ct[rownames(meta), 3]
```

### Sample QC

```{r}
# EWAStools
# ewas_meth <- read_idats(pData(RGset)$Basename)
# ctrls <- control_metrics(ewas_meth)
# pData(GRset.raw)$failed <- sample_failure(ctrls)
# table(pData(GRset.raw)$failed)

sampleNames(RGset) <- rownames(meta)

# minfi
GRset.raw <- preprocessRaw(RGset)
minfi_controlqc <- getQC(GRset.raw)
controlqc <- plotQC(minfi_controlqc)

# Other checks
out1 <- DetPBisCTest(RGset)
out2 <- outlyx(RGset) 

GRset.raw <- GRset.raw[, grep("HC|Mom|Dad|Sis", colnames(GRset.raw))] # Check to see if any outlier is weird
out3 <- detectOutlier(as.matrix(getBeta(GRset.raw))) %>% which(.) # Take too long to run
out4 <- locfdr_LMM(getBeta(GRset.raw), pData(GRset.raw))
# No outliers! All samples' quality is good
```

### Probe QC

```{r}
detP <- minfi::detectionP(as(RGset, "RGChannelSet")) 
bc <- beadcount(RGset)
RGset <- pfilter(RGset, pn = detP, bc = bc, pnthresh = 0.001) # If filtering is done before sex prediction then the prediction is inaccurate
# 0 samples having 1 % of sites with a detection p-value greater than 0.001 were removed 
# Samples removed:  
# 964 sites were removed as beadcount <3 in 5 % of samples 
# 4694 sites having 1 % of samples with a detection p-value greater than 0.001 were removed 
GRset <- preprocessFunnorm(RGset)
```

### Remove duplicated probes???
Weird duplicated probe names _TC / _BC - remove duplicated ones

```{r}
library(minfi)
library(dplyr)
library(Metrics)

bt <- getBeta(GRset) # after preprocessFunnorm

# Get the duplicated probes
probes <- gsub("_.*", "", rownames(bt))
probes_dup <- probes[duplicated(probes)]

# Calculate correlation and rmse
probe_stat <- sapply(unique(probes_dup), function(x){
    dat <- bt[grep(x, rownames(bt)), ] 
    stat <- apply(combn(rownames(dat), 2), 2, function(y){ # find all combination and calculate rmse
        r <- cor.test(dat[y[1], ], dat[y[2], ], method = "pearson")$estimate
        rmse <- rmse(dat[y[1], ], dat[y[2], ])
        return(c(r, rmse, y))
    }) 
    rownames(stat) <- c("r", "rmse", "dup1", "dup2")
    stat <- stat[, stat["r", ] > 0.9 | stat["rmse", ] < 0.03]
    return(stat)
}) # large list returned - messy

# Diagnostic plot
# ggplot(probe_stat, aes(r, rmse)) + 
#     geom_point() +
#     theme_bw() +
#     geom_vline(xintercept = c(0.5, 0.9), linetype = "dotted") + 
#     geom_hline(yintercept = 0.03, linetype = "dotted") 

# Identify which dups to remove and which to keep
probeset_bad <- names(probe_stat)[do.call(c, lapply(probe_stat, isEmpty))] # remove 852 probes
probeset_1pair <- names(probe_stat)[do.call(c, lapply(probe_stat, is.vector))] %>%
    probe_stat[.] %>% 
    do.call(rbind, .) # keep the pair
probeset_many <- names(probe_stat) %>% 
    .[do.call(c, lapply(probe_stat, is.array))] %>%
    .[!. %in% probeset_bad] %>%
    probe_stat[.] 
probeset_many <- lapply(probeset_many, function(x){
    dups <- c(x["dup1", ], x["dup2", ])
    most.rep <- max(table(dups))
    return(names(table(dups) == most.rep))
}) # return the duplicates that correlate with highest number of duplicates

# Keep (and average) the dups 
bt_unique <- bt[!probes %in% probes_dup, ] # the ones that don't have dups
rownames(bt_unique) <- gsub("_.*", "", rownames(bt_unique))
bt_1pair <- apply(probeset_1pair, 1, function(x){
    dat <- bt[x[c("dup1", "dup2")], ] 
    bt.avg <- colMeans(dat)
    return(bt.avg)
}) %>% t()
bt_many <- lapply(probeset_many, function(x){
    dat <- bt[x, ] 
    bt.avg <- colMeans(dat)
    return(bt.avg)
}) %>% do.call(rbind, .)

beta <- rbind(bt_unique, bt_1pair, bt_many) # New betas
anno <- anno[rownames(beta), ]
save(beta, meta, anno, file = "RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")
```


## Data exploration - cell type, DNAm age, sex, etc

### Check sex

```{r}
BetaPlot(beta[anno$CHR == "X", ], meta, "predictedSex") #looks good
BetaPlot(beta[anno$CHR == "Y", ], meta, "predictedSex") 
```

### Check time point

```{r}
pheatmap(beta[sample(1:nrow(beta), 10000), ], show_rownames = F, scale = "row")
pheatmap(beta[sample(1:nrow(beta), 10000), ], show_rownames = F, scale = "none")

meta$Sample_Name <- meta$Sample_Name %>% gsub("P.*", "P", .) %>% gsub("R.*", "R", .)
BetaPlot(beta[sample(1:nrow(beta), 10000), ], meta, "Time_Point") 
BetaPlot(beta[sample(1:nrow(beta), 10000), ], meta, "Sample_Name") 
BetaPlot(beta[sample(1:nrow(beta), 10000), ], meta, "Disease_Status") 
```

### Check SNPs

```{r}
library(ggdendro)
snps <- getSnpBeta(RGset)
colnames(snps) <- meta$Sample_Group
D <- dist(t(snps)) #snp probes
hc <- hclust(D, method = "ward.D2")
ggdendrogram(hc, rotate = TRUE)
```

### EstimateCellCounts2

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")

dataset <- beta

# ECC2 doesn't work - need to run homebrew MRP 
source("../../Functions/MRP_accessory.R")
source("../../Functions/pickCompProbesCaret.R")

if (verbose)
    cat("Loading Reference Dataset.\n")
load("/mnt/scratch/KoborLab/Personal_Folders/mfu/Reference/FlowSorted.BloodExtended.EPIC_FN.RData")

sampType = rep("PB", ncol(dataset)) # c("PB", "CB")
class = "betas" # c("rgset", "betas")
norm = "QN.b" # c("Noob", "FN", "QN", "QN.b", "none")
normComb = TRUE
probeList = "Ttest" #c("Ttest", "Caret", "IDOL", "DHS")
method = "CP" #c("CP", "RPC", "SVR")
probeSelect = "both" #c("both", "any", "pval")
conditions = NULL
nProbes = 100
verbose = TRUE
plotRef = FALSE
removenRBC = T
EPIConly = F
seed = 3
reference = FlowSorted.BloodExtended.EPIC.FN # c(FlowSorted.CordBlood.450k.FN, FlowSorted.Blood.450k.FN, FlowSorted.Blood.EPIC.FN, FlowSorted.BloodExtended.EPIC.FN)
cellTypes = c("Bas", "Bmem", "Bnv", "CD4mem", "CD4nv",
              "CD8mem", "CD8nv", "Eos", "Mono", "Neu", "NK", "Treg")
caretMods = c("EL", "BLR", "CART", "RF", "GBM", "RFEnNB", "RFEnSVM") # c("EL", "BLR", "CART", "RF", "GBM", "RFEnLDA", "RFEnRF", "RFEnNB", "RFEnSVM", "RFEnNN")

require(dplyr)
require(limma)
require(genefilter)
#require(FlowSorted.Blood.450k)
require(FlowSorted.Blood.EPIC)
#require(FlowSorted.CordBloodCombined.450k)
require(IlluminaHumanMethylation450kmanifest)
require(IlluminaHumanMethylationEPICmanifest)
#require(ExperimentHub)
#require(EpiDISH)
#hub <- ExperimentHub()
library(SIS)
```

#### Combine data / normalize

```{r}
if (verbose)
    cat("Starting Cell Type Estimation.\n")
# if (removenRBC == T) {
#     cellTypes <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran")
# } else {
#     cellTypes <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran", "nRBC")
# }
if (norm == "FN") {
    processMethod <- "preprocessFunnorm"
    if (class == "betas") stop("A RGChannelSet is required for functional normalization")
} else if (norm == "Noob") {
    processMethod <- "preprocessNoob"
    if (class == "betas") stop("A RGChannelSet or is required for Noob normalization")
} else if (norm == "QN") {
    processMethod <- "preprocessQuantile"
    if (class == "betas") stop("A RGChannelSet is required for this quantile normalization method. If you only have betas, set normalization method to QN.b instead")
} else if (norm == "QN.b") {
    processMethod <- "normalizeQuantiles"
    if (class == "rgset") stop("QN.b is exclusively for beta matrix input. Use QN instead if you have an RGChannelSet")
}
sampCT <- rep("WBC", ncol(dataset))
if (norm != "none") {
    processMethod <- get(processMethod)
}

### Data normalization
if (verbose) 
    cat("Combining Data with Flow Sorted Data and Normalizing.\n")
if (class == "betas") {
    # if (all(sampType %in% "CB")) {
    #     ref <- betas(reference[pData(reference)$SampType == "CB", ])
    # } else {
    #     ref <- betas(reference)
    # }
    if (class(reference) == "MethyLumiSet"){
        ref <- betas(reference)
    } else if (class(reference) %in% c("RGChannelSetExtended", "RGChannelSet", "GenomicRatioSet")){
        ref <- getBeta(reference)
    }
    commonprobe <- intersect(as.character(rownames(dataset)), as.character(rownames(ref)))
    if (norm == "QN.b") { 
        comb <- cbind(dataset[commonprobe, ], ref[commonprobe, ])
        comb.n <- processMethod(comb) 
        samp.n <- comb.n[, colnames(dataset)]
        ref.n <- comb.n[, colnames(ref)]
    } else if (norm == "none") {
        samp.n <- dataset[commonprobe, ]
        ref.n <- ref[commonprobe, ]
    }
} else {
    dataset <- as(dataset, "RGChannelSet")
    if (norm == "none") {
        commonprobe <- intersect(as.character(rownames(dataset)), as.character(rownames(BloodCell)))
        samp.n <- betas(BloodCell)[commonprobe, ]
        ref.n <- getBeta(dataset)[commonprobe, ]
        
    } else if (normComb) { # Combine all the datasets and normalize
        combRGset <- combineArrays(dataset, reference, outType = "IlluminaHumanMethylation450k")
        combRGset.N <- processMethod(combRGset)
        comb.n <- getBeta(combRGset.N)
        samp.n <- comb.n[, colnames(dataset)]
        ref.n <- comb.n[, colnames(reference)]
    } 
    
}

combMeta <- data.frame(sampleNames = c(colnames(samp.n), colnames(ref.n)),
                       studyIndex = rep(c("user", "reference"), times = c(ncol(samp.n), ncol(ref.n))),
                       sampleType = c(sampType, as.character(pData(reference)$SampType)),
                       cellType = c(sampCT, as.character(pData(reference)$CellType)), 
                       stringsAsFactors = FALSE)
refMeta <- combMeta[combMeta$studyIndex == "reference", ]
sampMeta <- combMeta[combMeta$studyIndex == "user", ]

# save(ref.n, samp.n, combMeta, file = "MRPref_CHILD_FN_0.RData")
# save(ref.n, samp.n, combMeta, file = "MRPref_CHILD_FN_1.RData")
# save(ref.n, samp.n, combMeta, file = "MRPref_CHILD_FN_5.RData")
```

#### Pick probes

```{r}
### Pick probes and estimate weights
if (verbose)
    cat("Estimating Weights for Cell Type Prediction Based on Selected Probeset.\n")
if (probeList == "Ttest") {
    coefs <- pickCompProbes2(betas = ref.n, 
                             meta = refMeta, 
                             nP = nProbes,
                             ct = cellTypes, 
                             ps = probeSelect, 
                             p.val = 0.05, 
                             min.delta.beta = 0, 
                             plot = plotRef) # Call the pickCompProbes2 function below to select the probes that can best discern cell types and calculate weights
} else if (probeList == "Caret") {
    coefs_caret <- pickCompProbesCaret(betas = ref.n, 
                                       meta = refMeta, 
                                       ct = cellTypes, 
                                       caretMods = caretMods, # caretMods = c("EL", "BLR", "CART", "RF", "GBM", "LDA", "RFEnRF", "RFEnNB", "RFEnSVM", "RFEnNN")
                                       verbose = verbose, 
                                       filtern = 10000,
                                       seed = seed)
} else {
    load("/mnt/scratch/KoborLab/Personal_Folders/mfu/Reference/Probe_libraries.RData")
    if (probeList == "IDOL") {
        if (unique(sampType) == "CB") {
            pLib <- idol.c
        } else if (nrow(samp.n) > 622399) {
            pLib <- idol.a_EPIC
        } else {
            pLib <- idol.a_450
        }
    } else if (probeList == "DHS") {
        pLib <- DHS
    }
    coefs <- pickCompProbes2(betas = ref.n, meta = refMeta, nP = nProbes, 
                             ct = cellTypes, trainingProbes = pLib, plot = plotRef) 
}

```

#### Estimate proportion

```{r}
### Estimate cell type proportion
if (verbose)
    cat("Estimating Composition Based on Selected Projection Method.\n")
projectionMethod <- get(method)

if (probeList == "Caret"){
    out <- lapply(coefs_caret$probeCoefs, function(coefs){
        mat <- samp.n[rownames(coefs), ]
        mat <- as.matrix(mat[complete.cases(mat), ])
        mat.cb <- mat[, sampMeta$sampleType == "CB"]
        mat.pb <- mat[, sampMeta$sampleType == "PB"]
        coefs.cb <- as.matrix(coefs)
        coefs.pb <- coefs.cb[, colnames(coefs.cb) != "nRBC"] # For peripheral blood, remove nRBC in prediction
        if (ncol(mat.cb) > 0) {
            if (is.null(conditions)) counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb) %>% 
                    as.data.frame()# Using the weights generated in the last step to stimate the proportion of each cell type
            else counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb, conditions = conditions) %>% 
                    as.data.frame()
        } 
        if (ncol(mat.pb) > 0) {
            if (is.null(conditions)) counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb) %>% 
                    as.data.frame()
            else counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb, conditions = conditions) %>% 
                    as.data.frame()
            counts.pb$nRBC <- 0
        }
        if (exists("counts.cb") & exists("counts.pb")) {
            counts <- rbind(counts.cb, counts.pb) %>% .[colnames(mat), ]
        } else if (exists("counts.cb") & !exists("counts.pb")) {
            counts <- counts.cb
        } else if (!exists("counts.cb") & exists("counts.pb")) {
            counts <- counts.pb
        }
        return(counts)
    })
} else {
    mat <- samp.n[rownames(coefs), ]
    mat <- as.matrix(mat[complete.cases(mat), ])
    mat.cb <- mat[, sampMeta$sampleType == "CB"]
    mat.pb <- mat[, sampMeta$sampleType == "PB"]
    coefs.cb <- as.matrix(coefs)
    coefs.pb <- coefs.cb[, colnames(coefs.cb) != "nRBC"]
    if (ncol(mat.cb) > 0) {
        if (is.null(conditions)) counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb) %>% 
                as.data.frame() 
        else counts.cb <- projectionMethod(samp.n = mat.cb, coef = coefs.cb, conditions = conditions) %>% 
                as.data.frame()
    } 
    if (ncol(mat.pb) > 0) {
        if (is.null(conditions)) counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb) %>% 
                as.data.frame()
        else counts.pb <- projectionMethod(samp.n = mat.pb, coef = coefs.pb, conditions = conditions) %>% 
                as.data.frame()
        counts.pb$nRBC <- 0
    }
    if (exists("counts.cb") & exists("counts.pb")) {
        counts <- rbind(counts.cb, counts.pb) %>% .[colnames(mat), ]
    } else if (exists("counts.cb") & !exists("counts.pb")) {
        counts <- counts.cb
    } else if (!exists("counts.cb") & exists("counts.pb")) {
        counts <- counts.pb
    }
    out <- counts
}

# out <- list(counts = counts, coefs = coefs, betas.n = samp.n)
```

#### Plot cell type

```{r}
meta <- cbind(meta, out)

BloodPlot <- function(mt, vartype = c("categorical", "continuous"), varname = NULL, 
                      tissue = c("blood", "bloodextended", "cord")) {
    
    require(dplyr)
    require(ggpubr)
    require(gridExtra)
    
    if (tissue == "blood"){
        ct <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran")
    } else if (tissue == "bloodextended"){
        ct <- c("Bas", "Bmem", "Bnv", "CD4mem", "CD4nv",
                "CD8mem", "CD8nv", "Eos", "Mono", "Neu", "NK", "Treg")
    } else if (tissue == "Cord"){
        ct <- c("CD8T", "CD4T", "NK", "Bcell", "Mono", "Gran", "nRBC")
    }
    counts <- mt[, c("Sample_Name", ct)] %>% as.data.table()
    counts_plot <- melt(counts, id.vars = "Sample_Name")
    covar <- mt[, c("Sample_Name", varname)]
    plt <- merge(counts_plot, covar, by = "Sample_Name") %>% 
        as.data.frame()
    
    p1 <- ggplot(plt, aes(get(varname), value, fill = get(varname))) +
        geom_boxplot(alpha = 0.2) +
        geom_point(shape = 21, aes(group = Sample_Name), 
                   position = position_jitter(w = 0.1)) +
        xlab(NULL) +
        ylab("Cell Proportion") +
        theme_bw() + 
        theme(axis.text = element_text(size = 12, color = "black"),
              axis.title = element_text(size = 14),
              legend.text = element_text(size = 11),
              legend.title = element_text(size = 14), 
              strip.text = element_text(size = 14),
              axis.text.x = element_blank(),
              axis.ticks.x = element_blank()) +
        facet_wrap(~ variable)

    # if (vartype == "categorical") {
    #     p1 <- p1 + stat_compare_means(method = "t.test")
    # } 
    plot(p1)
}

BloodPlot(mt = meta, vartype = "categorical", varname = "Sample_Group", tissue = "bloodextended") + 
    scale_fill_manual(values = group.colors) 

# Compare predicted and flow cell type proportion

meta$CD8_perc_DNAm <- meta$CD8mem + meta$CD8nv
meta$CD4_perc_DNAm <- meta$CD4mem + meta$CD4nv

cor.test(meta$CD4_perc_flow, meta$CD4_perc_DNAm)
cor.test(meta$CD8_perc_flow, meta$CD8_perc_DNAm)

ggplot(meta, aes(CD4_perc_DNAm, CD4_perc_flow)) + 
    geom_smooth(method = "lm", color = "gray") + 
    geom_point(aes(color = Sample_Group), size = 2.5) + 
    scale_color_manual(values = group.colors) + 
    theme_bw() + 
    theme(text = element_text(size = 14))
ggplot(meta, aes(CD8_perc_DNAm, CD8_perc_flow)) + 
    geom_smooth(method = "lm", color = "gray") + 
    geom_point(aes(color = Sample_Group), size = 2.5) + 
    scale_color_manual(values = group.colors) + 
    theme_bw() + 
    theme(text = element_text(size = 14))
```

#### Make cell type PCs

```{r}
source("../../Functions/pcaCoDa_NG.R")

ct <- meta[, c("CD4mem", "CD4nv", "CD8mem", "CD8nv", "Treg")] %>% 
    as.data.frame()
sum(ct==0) #Are there any proportions predicted to be 0?
ct <- (ct + 0.0001) #If necessary, add the offset of 0.001
min(ct) # Cannot be = or < 0

pca_object <- pcaCoDa(ct)
pca_object$eigenvalues / sum(pca_object$eigenvalues)

CTP <- as.data.frame(pca_object$scores)
colnames(CTP) <- c("CTP_PC1", "CTP_PC2", "CTP_PC3", "CTP_PC4")
rownames(CTP) <- rownames(ct)
identical(rownames(meta), rownames(CTP))
meta <- cbind(meta, CTP)

save(beta, meta, anno, file = "RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")
```

### Remove X- and Y-chromosome probes

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")

beta.noxy <- beta[!anno$CHR %in% c("X", "Y"), ]
anno.noxy <- anno[rownames(beta), ]
meta.noxy <- meta

save(beta.noxy, anno.noxy, meta.noxy, file = "RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")
```

### DNAm age

```{r}
library(rstatix)
library(colorblindr)
library(ggpubr)
load("RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")

# DNAm Age
bt <- cbind(CpG = rownames(beta), as.data.frame(beta))
cpgs.missing <- checkClocks(bt)
DNAmage <- DNAmAge(bt, clocks = c("Horvath", "Hannum", "skinHorvath", "Levine", "Wu"))
meta <- cbind(meta, DNAmage[, 2:6])
meta$Sample_Group <- factor(meta$Sample_Group, level = c('unrelated healthy control', 'family control', 'patient_EV', 'patient_WT'))

group.colors <- c("family control" = "#F9791EFF", "unrelated healthy control" = "#5E81ACFF", "patient_WT" ="#44AA99", "patient_EV" = "#403369FF")
# group.colors <- c("EV" ="#550307FF", "WT" = "#4B644BFF")

test <- ggplot(as.data.frame(meta), aes(Age, Horvath, color = Sample_Group)) + 
    geom_point(size = 3, aes(shape = Time_Point)) +
    geom_abline() + 
    theme_bw() + 
    scale_color_manual(values = group.colors) +
    theme(axis.text.x = element_text(vjust = 0.5, hjust = 1), 
          text = element_text(size = 15)) + 
    labs(x = "Chronological Age", y = "Horvath Epigenetic Clock DNAm Age") 
    # ggforce::geom_mark_ellipse(aes(fill = Sample_Group, color = Sample_Group), linetype = "dashed")
cvd_grid(test)

stat.test <- t_test(Horvath ~ Disease_Status, data = as.data.frame(meta)) %>% 
    add_xy_position(x = "Disease_Status") %>% 
    .[.$group1 == "Patient_EV" & .$group2 == "Patient_WT", ] 

ggplot(as.data.frame(meta[meta$Sample_Group != "family control", ]), 
       aes(Disease_Status, Horvath)) + 
    geom_boxplot(alpha = 0.8, aes(fill = Sample_Group)) + 
    geom_point(size = 2) +
    theme_bw() + 
    scale_fill_manual(values = group.colors) +
    # scale_color_manual(values = group.colors) +
    theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1), 
          text = element_text(size = 15)) + 
    labs(x = "", y = "Horvath Epigenetic Clock DNAm Age") + 
    stat_pvalue_manual(stat.test, label = "p", y.position = 60) +
    ylim(0, 65) # %>% cvd_grid()

test <- lm(Horvath ~ Disease_Status + Time_Point, data = meta[meta$Disease_Status != "HC_EV", ])
summary(test)

test <- meta[meta$Disease_Status != "HC_EV", ] 
test$Disease_Status <- gsub("Patient_EV", 0, test$Disease_Status) %>% 
    gsub("Patient_WT", 1, .) %>% 
    as.numeric()

save(beta, meta, anno, file = "RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")
```



#### Check to see if there is global de-methylation

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")

plt <- beta[rownames(beta) %in% coefHorvath$CpGmarker, ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
plt <- plt[, c("HC1_T1", "HC1_T2", "HC2_T1", "HC2_T2", "HC3_T1", "HC3_T2", "Dad_T1", "Dad_T2", "Mom_T1", "Mom_T2", "Sister_T1", "Sister_T2", "P_T1", "P1_T2", "P2_T2", "P3_T2", "R_T1", "R1_T2", "R2_T2", "R3_T2")] 
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # Does not clearly show demethylation pattern
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # Does not clearly show demethylation pattern
sapply(unique(meta$Sample_Group), function(x) mean(plt[, rownames(meta)[meta$Sample_Group == x]]))

```

#### Use REMP to look at DNAm in repetitive elements (LINE1 and Alu)

```{r}

```



### Correct for cell type - correct for flow CD8 proportion
Even though cell types are not in top PCs

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")

beta <- beta.noxy
meta <- meta.noxy
residuals <- t(apply(beta, 1, function(x){
    x <- as.numeric(x)
    residuals(summary(lm(x ~ CD8_perc_DNAm, data = meta)))
}))
colnames(residuals) <- colnames(beta)
adj.residuals <- residuals + matrix(apply(beta, 1, mean), nrow = nrow(residuals), ncol = ncol(residuals))
adj.residuals[adj.residuals <= 0] <- 0.0001 # convert any values that are less than or equal to zero to 0.0001
adj.residuals[adj.residuals > 1] <- 0.9999

save(adj.residuals, meta.noxy, anno.noxy, file = "RData/906-ASXL1_Tcell_betas_flowct_adjusted_noxy_t1_t2.RData")
save(adj.residuals, meta.noxy, anno.noxy, file = "RData/906-ASXL1_Tcell_betas_DNAmct_adjusted_noxy_t1_t2.RData")
```


### Variable correlation matrix
```{r}
library(corrplot)

load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")
meta <- meta.noxy

plt <- meta[meta$Time_Point == "T2", c("Disease_Status", # Sample groups
                "xMed", "yMed", "Sentrix_Row", # Technical batch
                "predictedSex", # demographic variables
                "CD4mem", "CD4nv", "CD8mem", "CD8nv", "Treg", # cell type
                "CD8_perc_DNAm", "CD4_perc_DNAm",
                "CD8_perc_flow", "CD4_perc_flow",
                "CTP_PC1", "CTP_PC2", "CTP_PC3", "CTP_PC4", # Cell type PCs
                "Horvath", "Hannum", "Levine", "skinHorvath") # DNAm age
            ] %>% as.data.frame()
plt$Disease_Status <- plt$Disease_Status %>% 
    gsub("HC.*", 0, .) %>% 
    gsub("Patient_WT", 1, .) %>% 
    gsub("Patient_EV", 2, .) %>% 
    as.numeric()
plt$predictedSex <- plt$predictedSex %>% 
    gsub("F", 0, .) %>% 
    gsub("M", 1, .) %>% 
    as.numeric()

# Calculate correlation statistics
cor.mat <- cor(plt)

# Calculate 
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(plt)
head(p.mat[, 1:5])

library(RColorBrewer)
library(corrplot)
corrplot(cor.mat, type="upper", order = "original", 
         col = rev(brewer.pal(n = 8, name = "RdBu")), 
         tl.col = "black", tl.srt = 45,
         p.mat = p.mat, sig.level = 0.05, 
         pch.col = "gray", pch.cex = 2, diag = F)

col <- colorRampPalette(c("#BB4444", "#EE9988", "#FFFFFF", "#77AADD", "#4477AA"))
corrplot(cor.mat, method = "color", col = col(200), 
         type = "upper", order = "original", 
         addCoef.col = "black", # Add coefficient of correlation
         tl.col = "black", tl.srt = 45, #Text label color and rotation
         # Combine with significance
         p.mat = p.mat, sig.level = 0.05, 
         insig = "n", diag = F)
```

### Check DNAm clustering - Hierarchical and PCA

```{r}
# Heatmap
beta <- beta.noxy[, meta$Time_Point == "T2"]
meta <- meta.noxy[colnames(beta), ]
bt <- beta[sample(1:nrow(beta),20000), ]
pheatmap(bt, show_rownames = F)

# PCA
source("../../Functions/heatscreesimple.R")
PCA.C <- prcomp(beta)

meta_cat <- meta[, c("predictedSex", "Sample_Group", "Disease_Status", "Slide")] 
colnames(meta_cat) <- c("Predicted_Sex", "Sample_Group", "Disease_Status", "Sentrix_ID")
meta_con <- meta[, c("Age", "Sentrix_Row", "CTP_PC1", "CTP_PC2", "CTP_PC3", "CTP_PC4", "CD4_perc_DNAm", "CD8_perc_DNAm")] 
heatscreesimple(PCA.C$rotation, PCA.C$sdev^2, meta_cat, meta_con, 5)

pcaObj <- PCA.C$rotation %>% as.data.frame() %>% cbind(., meta[, c("Sample_Group", "predictedSex", "Time_Point", "CD4_perc_flow", "CD8_perc_flow")])
group.colors <- c("family control" = "#F9791EFF", "unrelated healthy control" = "#5E81ACFF", "patient_WT" ="#44AA99", "patient_EV" = "#403369FF")
ggplot(pcaObj, aes(PC1, PC2, color = Sample_Group)) + 
    geom_point(size = 4, aes(shape = predictedSex)) + 
    theme_bw() +
    # ggforce::geom_mark_ellipse(aes(fill = Sample_Group, color = Sample_Group), linetype = "dashed") +
    scale_color_manual(values = group.colors) +
    scale_fill_manual(values = group.colors)
```

### Batch correction

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")
load("RData/906-ASXL1_Tcell_betas_ct_adjusted_t1_t2.RData")

adj.residuals[adj.residuals == 0] <- 1e-5
dat <- as.matrix(beta2m(adj.residuals))

beta[beta == 0] <- 1e-5
dat <- as.matrix(beta2m(beta))
# Subset out only blood & buccal and healthy + mut sample to make batch correction better
# MLset.C <- MLset.C[, sampleNames(MLset.C) %in% rownames(meta[meta$Tissue %in% c("BEC", "PBMC", "WB"), ])]
# MLset.C <- MLset.C[, sampleNames(MLset.C) %in% rownames(meta[meta$Disease_Status %in% c("Healthy", "Crohn's disease", "FASD", "ASXL1"), ])]
# meta <- pData(MLset.C)
# dim(MLset.C)
# Features  Samples 
#   405686      730 
M_c1 <- ComBat(dat, batch = meta$Slide, mod = , par.prior = T) # slide and timepoint confounds
M_c2 <- ComBat(M_c1, batch = meta$Sentrix_Row, mod = NULL, par.prior = T)

beta.BC <- m2beta(M_c2)
meta.BC <- meta
save(beta.BC, meta.BC, anno, file = "RData/907-ASXL1_Tcell_batch_corrected_t1_t2.RData")
save(beta.BC, meta.BC, anno, file = "RData/907-ASXL1_Tcell_batch_corrected_t1_t2_NOT_CT_corrected.RData")
```

### Check for rep correlation

```{r}
source("../../Functions/RepCorTest.R")
load("RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")
load("RData/906-ASXL1_Tcell_betas_ct_adjusted_t1_t2.RData")
load("RData/907-ASXL1_Tcell_batch_corrected_t1_t2.RData")

reps <- c("P1_T2", "P3_T2")
Rnorm <- beta[, reps] # normalized, outlier removed
Rcc <- adj.residuals[, reps]  # celltype corrected
Rbc <- beta.BC[, reps]  # batch corrected

# Calculate correlation between tech reps after each pre-processing step
Cnorm <- cor(na.omit(Rnorm))[1,2]
Ccc <- cor(na.omit(Rcc))[1,2]
Cbc <- cor(na.omit(Rbc))[1,2]
Cval <- c(Cnorm, Ccc, Cbc)
Cname <- c(1:length(Cval)) %>% as.character(.)
Cdf <- data.frame(Cname, Cval)
    
p1 <- ggplot(Cdf, aes(Cname, Cval)) +
    geom_point(color = "#005C66", alpha = 0.75, size = 3.5) +
    xlab("Pre-Processing and Normalization Step") +
    ylab("Spearman's Correlation (rho)") +
    scale_x_discrete(breaks = c(1:length(Cval)), 
                     labels = c("Normalized", "Celltype Corrected", "Batch Corrected")) +
    theme_bw(base_size = 10)

# Calculate root mean square error between tech reps after each pre-processing step    
Enorm <- rmse(na.omit(Rnorm)[,1], na.omit(Rnorm)[,2])
Ecc <- rmse(na.omit(Rcc)[,1], na.omit(Rcc)[,2])
Ebc <- rmse(na.omit(Rbc)[,1], na.omit(Rbc)[,2])
Eval <- c(Enorm, Ecc, Ebc)
Ename <- c(1:length(Eval)) %>% as.character(.)
Edf <- data.frame(Ename, Eval)
    
p2 <- ggplot(Edf, aes(Ename, Eval)) +
        geom_point(color = "#733556", alpha = 0.75, size = 3.5) +
        xlab("Pre-Processing and Normalization Step") +
        ylab("Root Mean Square Error") +
        scale_x_discrete(breaks = c(1:length(Eval)), 
                         labels = c("Normalized", "Celltype Corrected", "Batch Corrected")) +
        theme_bw(base_size = 10)

grid.arrange(p1, p2)
```


```{r}
bt <- adj.residuals %>%
    .[sample(1:nrow(.), 20000), ]
bt <- beta.BC[sample(1:nrow(beta.BC),20000), ]
mt <- meta.BC[colnames(bt), ]

pheatmap(bt, show_rownames = F, scale = "row")
BetaPlot(bt[sample(1:nrow(bt), 10000), ], mt, "Time_Point") 
BetaPlot(bt[sample(1:nrow(bt), 10000), ], mt, "Sample_Group") 
BetaPlot(bt[sample(1:nrow(bt), 10000), ], mt, "Disease_Status") 
```


## Data analysis

### Check if the patient samples are outside the HC range

```{r}
load("RData/907-ASXL1_Tcell_batch_corrected_t1_t2.RData")

beta <- beta.BC # if using cell type corrected betas

# Compared to IQR / SD range

# Subset for patient and HCs
beta.pat <- beta[, meta$Disease_Status == "Patient_EV"]
beta.res <- beta[, meta$Disease_Status == "Patient_WT"]
beta.ref <- beta[, meta$Disease_Status == "HC_EV"]

# Calculate the reference range
beta.refIQR <- apply(beta.ref, 1, function(x) {quantile(x, c(0.025, 0.25, 0.5, 0.75, 0.975))}) %>% t() %>% as.data.frame()
beta.refIQR$iqr <- beta.refIQR[, 4] - beta.refIQR[, 2]
beta.refIQR$beta.refIQRl <- beta.refIQR[, 2] - 1.5*beta.refIQR$iqr
beta.refIQR$beta.refIQRh <- beta.refIQR[, 4] + 1.5*beta.refIQR$iqr
beta.refSD <- apply(beta.ref, 1, sd)
beta.refM <- apply(beta.ref, 1, mean)

ASXL1.test <- cbind(beta.refIQR, beta.refSD, beta.refM, beta.pat, beta.res) %>% as.data.frame()
ASXL1.test$beta.refSD2l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*2)
ASXL1.test$beta.refSD2h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*2)
ASXL1.test$beta.refSD3l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*3)
ASXL1.test$beta.refSD3h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*3)
ASXL1.test$beta.refSD4l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*4)
ASXL1.test$beta.refSD4h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*4)
ASXL1.test$beta.refSD5l <- ASXL1.test$beta.refM - (ASXL1.test$beta.refSD*5)
ASXL1.test$beta.refSD5h <- ASXL1.test$beta.refM + (ASXL1.test$beta.refSD*5)

# Set empty variable for tests
ASXL1.test$IQR.test.pat <- NA
ASXL1.test$IQR.test.res <- NA
ASXL1.test$IQR2.test.pat <- NA
ASXL1.test$IQR2.test.res <- NA
ASXL1.test$SD2.test.pat <- NA
ASXL1.test$SD2.test.res <- NA
ASXL1.test$SD3.test.pat <- NA
ASXL1.test$SD3.test.res <- NA
ASXL1.test$SD4.test.pat <- NA
ASXL1.test$SD4.test.res <- NA
ASXL1.test$SD5.test.pat <- NA
ASXL1.test$SD5.test.res <- NA

for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "2.5%"] | 
       beta.pat[i] > ASXL1.test[i, "97.5%"]) {
        ASXL1.test$IQR.test.pat[i] <- "s"
    } else {
        ASXL1.test$IQR.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "2.5%"] | 
       beta.res[i] > ASXL1.test[i, "97.5%"]) {
        ASXL1.test$IQR.test.res[i] <- "s"
    } else {
        ASXL1.test$IQR.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refIQRl"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refIQRh"]) {
        ASXL1.test$IQR2.test.pat[i] <- "s"
    } else {
        ASXL1.test$IQR2.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refIQRl"] | 
       beta.res[i] > ASXL1.test[i, "beta.refIQRh"]) {
        ASXL1.test$IQR2.test.res[i] <- "s"
    } else {
        ASXL1.test$IQR2.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD2l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD2h"]) {
        ASXL1.test$SD2.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD2.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD2l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD2h"]) {
        ASXL1.test$SD2.test.res[i] <- "s"
    } else {
        ASXL1.test$SD2.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD3l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD3h"]) {
        ASXL1.test$SD3.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD3.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD3l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD3h"]) {
        ASXL1.test$SD3.test.res[i] <- "s"
    } else {
        ASXL1.test$SD3.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD4l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD4h"]) {
        ASXL1.test$SD4.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD4.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD4l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD4h"]) {
        ASXL1.test$SD4.test.res[i] <- "s"
    } else {
        ASXL1.test$SD4.test.res[i] <- "ns"
    }
}
for (i in 1:nrow(ASXL1.test)) {
    if(beta.pat[i] < ASXL1.test[i, "beta.refSD5l"] | 
       beta.pat[i] > ASXL1.test[i, "beta.refSD5h"]) {
        ASXL1.test$SD5.test.pat[i] <- "s"
    } else {
        ASXL1.test$SD5.test.pat[i] <- "ns"
    }
    if(beta.res[i] < ASXL1.test[i, "beta.refSD5l"] | 
       beta.res[i] > ASXL1.test[i, "beta.refSD5h"]) {
        ASXL1.test$SD5.test.res[i] <- "s"
    } else {
        ASXL1.test$SD5.test.res[i] <- "ns"
    }
}

sum(ASXL1.test$IQR.test.pat == "s") # 395147 / 358871
sum(ASXL1.test$IQR.test.res == "s") # 363057 / 221819
sum(ASXL1.test$IQR2.test.pat == "s") # 257476 / 92269
sum(ASXL1.test$IQR2.test.res == "s") # 210664 / 46893

hits_rescued <- rownames(ASXL1.test)[ASXL1.test$IQR2.test.pat == "s" & ASXL1.test$IQR2.test.res == "ns"] 
length(hits_rescued) # 151880
hits_not_rescued <- rownames(ASXL1.test)[ASXL1.test$IQR2.test.pat == "s" & ASXL1.test$IQR2.test.res == "s"] 
length(hits_not_rescued) # 132792

sum(ASXL1.test$SD2.test.pat == "s") # 264844 / 2766
sum(ASXL1.test$SD2.test.res == "s") # 216981 / 1333
sum(ASXL1.test$SD3.test.pat == "s") # 168067 / 0
sum(ASXL1.test$SD3.test.res == "s") # 106935 / 0
sum(ASXL1.test$SD4.test.pat == "s") # 106935 / 0
sum(ASXL1.test$SD4.test.res == "s") # 62515 / 0
sum(ASXL1.test$SD5.test.pat == "s") # 67239 / 0
sum(ASXL1.test$SD5.test.res == "s") # 36362 / 0

# Check for hyper / hypo methylation
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$beta.pat > ASXL1.test$beta.refM]) # 81
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$beta.pat < ASXL1.test$beta.refM]) # 2685
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.res == "s" & ASXL1.test$beta.res > ASXL1.test$beta.refM]) # 1209
length(rownames(ASXL1.test)[ASXL1.test$SD2.test.res == "s" & ASXL1.test$beta.res < ASXL1.test$beta.refM]) # 124


hits_rescued <- rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$SD2.test.res == "ns"] 
length(hits_rescued) # 50311 / 2766
hits_not_rescued <- rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "s" & ASXL1.test$SD2.test.res == "s"] 
length(hits_not_rescued) # 16928 / 0
hits_messed_up <- rownames(ASXL1.test)[ASXL1.test$SD2.test.pat == "ns" & ASXL1.test$SD2.test.res == "s"] 
length(hits_messed_up) # 19434 / 1333

# saveRDS(ASXL1.test, file = "RData/908-ASXL1_Tcell_global_test_n3.rds")
ASXL1.test.CC <- ASXL1.test
saveRDS(ASXL1.test.CC, file = "RData/908-ASXL1_Tcell_global_test_BC_t1_t2.rds")

# hist(ASXL1.test$beta.refSD)
# hist(ASXL1.test$beta.refM)

# Make Heatmap
beta <- beta[, c("HC1", "HC2", "HC3", "Dad", "Mom", "Sister", "P_EV", "P_WT ASXL1")] 
plt <- beta[hits_rescued, ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
pheatmap(plt, # [sample(1:nrow(plt),50000),]
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 75k
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F)

plt <- beta[hits_not_rescued, ] 
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F)
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F)

plt <- beta[hits_messed_up, ] 
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F)
pheatmap(plt,  # using the SD5 definition
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F)
```

#### Explore reference range comparison results

##### Defining regions for DMR analysis
```{r}
anno <- anno[!is.na(anno$MAPINFO), ]
anno <- anno[with(anno, order(CHR, MAPINFO)),]

# Region for finding DMR
anno$Mreg <- 1
reg <- 1
for (i in 2:nrow(anno)) {
    if (anno$MAPINFO[i] - anno$MAPINFO[i-1] > 1000) {
        reg <- reg + 1
    }
    anno$Mreg[i] <- reg
}

# Regions for gene region plotting
anno$Mreg_plt <- 1
reg <- 1
for (i in 2:nrow(anno)) {
    if (anno$MAPINFO[i] - anno$MAPINFO[i-1] > 10000) {
        reg <- reg + 1
    }
    anno$Mreg_plt[i] <- reg
}

rownames(anno) <- anno$IlmnID
saveRDS(anno, file = "../../Reference/EPICv2_fdat_Mreg.rds")

# anno$Mreg <- sapply(unique(anno$CHR), function(chr){
#     i <- 1
#     anno_chr <- anno[anno$CHR == chr, ] %>%
#         .[order(.$MAPINFO), ]
#     anno_chr$Mreg <- NA
#     apply(anno_chr, 1, function(cpg){
#         
#     })
# })
```

##### Map hits to annotation - plot DMRs

```{r}
load("RData/906-ASXL1_Tcell_betas_norm.RData")
ASXL1.test <- readRDS("RData/903-ASXL1_Tcell_global_test.rds")
anno <- readRDS("../../Reference/EPICv2_fdat_Mreg.rds")
source("../../Functions/plotmultigeneregion.R")
source("../../Functions/plotGeneRegion.R")

ASXL1.test.anno <- merge(ASXL1.test, anno[, c("CHR", "MAPINFO", "Mreg", "Mreg_plt", "UCSC_RefGene_Name", "GencodeCompV12_NAME")], by = 0)
rownames(ASXL1.test.anno) <- ASXL1.test.anno$Row.names

# Take the biggest DMRs
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s" & ASXL1.test.anno$SD5.test.res == "ns", "Mreg"]) %>% sort(decreasing = T) %>% .[.>3] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_rescued.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= 0.7] %>% 
    names(.) # At least 15% 

# Make table of hits
length(hits_rescued.dmr) #502 at Mreg size >= 5
View(ASXL1.test.anno[ASXL1.test.anno$Mreg %in% hits_rescued.dmr, ])

# ASXL1.test.dmr <- table(ASXL1.test.anno[test, "Mreg"]) %>% sort(decreasing = T) %>% .[.>=3] %>% names()
hits_rescued.dmr.gene <- sapply(hits_rescued.dmr, function(x) {
    test <- anno[anno$Mreg == x, "UCSC_RefGene_Name"] %>% 
               strsplit2(., ";") %>%
               as.vector() %>%
               unique()
    if (identical(test, character(0))) test <- ""
    if (length(test) > 1) {
        test <- test[test != ""]
        test <- paste0(test, collapse = ", ")
    }
    return(test)
}) 
dmr.genes <- do.call(c, hits_rescued.dmr.gene)
toString(shQuote(hits_rescued.dmr.gene))
genes <- c('LOC101927342', 'MAP4K4', 'MIR143HG, LOC728264', 'KCNB2', 'TMEM125', 'LOC400794', 'DISC1, TSNAX-DISC1', '', 'CACNA2D3', '', '', 'NXPH1', 'RNF19A', 'OR8D4', 'MTUS2', 'ARFRP1')
genes_plt <- genes
# If byvar  = "Mreg"
hits_rescued.dmr.geneanno <- anno[anno$Mreg %in% hits_rescued.dmr, ]
# If byvar  = "UCSC_RefGene_Name"
# hits_rescued.dmr.geneanno <- anno[grep(paste(genes_plt, collapse = "|"), anno$UCSC_RefGene_Name), ]

group.colors <- c("family control" = "#EBCB8BFF", "unrelated healthy control" = "#A3BE8CFF", "patient empty vector" ="#BF616AFF", "patient wild type" = "#B48EADFF")
mcolors <-  c("family control" = "#EBCB8BFF", "unrelated healthy control" = "gray", "patient empty vector" ="#BF616AFF", "patient wild type" = "#B48EADFF")
malpha <-  c("family control" = 0.3, "unrelated healthy control" = 0.3, "patient empty vector" = 1, "patient wild type" = 1)
plotmultigeneregion(bt = beta, # [, meta$Disease_Status == "Healthy Control" | rownames(meta) == "203077630141_R07C01"] 
                    plist = hits_rescued.dmr, #genes_plt
                    fdat = hits_rescued.dmr.geneanno,
                    byvar = "Mreg", #UCSC_RefGene_Name
                    colorvar = meta$Sample_Group, # [meta$Disease_Status == "Healthy Control" | rownames(meta) == "203077630141_R07C01"]
                    cscale = group.colors, 
                    ascale = malpha, 
                    title = genes_plt, 
                    hide.legend = T, 
                    nCol = 4) 

```

#### Enrichment analysis - ORA
Can only do ORA because no statistics is available

```{r}
# enrichment analysis with clusterProfiler
R.utils::setOption("clusterProfiler.download.method","auto")

# Define hits
dmr_size <- 2 # To be called a DMR, the region needs to have at least this many DMs
dmr_perc <- 0 # The hits need to encompass this percent of the region (to avoid very large regions with few hits)

# Rescued
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s" & ASXL1.test.anno$SD5.test.res == "ns", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_rescued.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% # At least 30% 
    names(.) 
genes_rescued <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_rescued.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""] # remove missing values

# The code for converting gene name to entrez ID if needed
# AnnotationDbi::select(org.Hs.eg.db,
#                       keys = .,
#                       columns = c("ENTREZID", "SYMBOL"),
#                       keytype = "SYMBOL") 

# Not rescued
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s" & ASXL1.test.anno$SD5.test.res == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_not_rescued.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_not_rescued <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_not_rescued.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique()%>%
    .[. != ""]

# Messed up by WT ASXL1
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "ns" & ASXL1.test.anno$SD5.test.res == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_messed_up.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_messed_up <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_messed_up.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# EV
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.pat == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_EV.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_EV <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_EV.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# WT ASXL1
hits.dmr <- table(ASXL1.test.anno[ASXL1.test.anno$SD5.test.res == "s", "Mreg"]) %>% sort(decreasing = T) %>% .[.>=dmr_size] 
Mreg_size <- table(anno$Mreg)[names(hits.dmr)] # Also filter by proportion of hits in a region
hits_WT.dmr <- (hits.dmr / Mreg_size) %>% 
    sort(decreasing = T) %>% 
    .[. >= dmr_perc] %>% 
    names(.)
genes_WT <- ASXL1.test.anno$UCSC_RefGene_Name[ASXL1.test.anno$Mreg %in% hits_WT.dmr] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

# Background genes measured on the array
genes_universe <- ASXL1.test.anno$UCSC_RefGene_Name %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""] 

# Hallmark enrichment - want to check IL2-STAT5 pathway
gs_hallmark <- msigdbr(species = "human", category = "H")
msigdbr_t2g <- gs_hallmark %>% 
    dplyr::distinct(gs_name, gene_symbol) %>% 
    as.data.frame 
# msigdbr_t2g = h_gene_sets %>% dplyr::distinct(gs_name, entrez_gene) %>% as.data.frame()
# enricher(gene = genes_rescued$ENTREZID, TERM2GENE = msigdbr_t2g, universe = genes_universe$ENTREZID)
(pathway_rescued <- enricher(gene = genes_rescued, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_HEDGEHOG_SIGNALING"
(pathway_not_rescued <- enricher(gene = genes_not_rescued, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_ESTROGEN_RESPONSE_LATE" "HALLMARK_MYOGENESIS"
(pathway_messed_up <- enricher(gene = genes_messed_up, TERM2GENE = msigdbr_t2g, universe = genes_universe))
(pathway_EV <- enricher(gene = genes_EV, TERM2GENE = msigdbr_t2g, universe = genes_universe)) # "HALLMARK_MYOGENESIS" "HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_ANGIOGENESIS" "HALLMARK_HEDGEHOG_SIGNALING" "HALLMARK_COAGULATION" "HALLMARK_ESTROGEN_RESPONSE_LATE" "HALLMARK_APICAL_JUNCTION"
(pathway_WT <- enricher(gene = genes_WT, TERM2GENE = msigdbr_t2g, universe = genes_universe)) # "HALLMARK_UV_RESPONSE_DN" "HALLMARK_ANDROGEN_RESPONSE"

gs_all <- msigdbr(species = "human")
gs_immune <- gs_all %>%
    dplyr::filter(gs_cat == "C7" & gs_subcat == "IMMUNESIGDB") %>%
    head()
msigdbr_t2g <- immune_gs %>% 
    dplyr::distinct(gs_name, gene_symbol) %>% 
    as.data.frame 
(pathway_rescued <- enricher(gene = genes_rescued, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_HEDGEHOG_SIGNALING"
#  [1] "GSE10147_IL3_VS_IL3_AND_HIVP17_STIM_PDC_DN"                                  "GSE22886_IL2_VS_IL15_STIM_NKCELL_UP"                                         "GSE21380_TFH_VS_GERMINAL_CENTER_TFH_CD4_TCELL_UP"      
#  [4] "GSE10239_MEMORY_VS_KLRG1HIGH_EFF_CD8_TCELL_UP"                               "GSE9946_IMMATURE_VS_MATURE_STIMULATORY_DC_DN"                                "GSE45739_UNSTIM_VS_ACD3_ACD28_STIM_NRAS_KO_CD4_TCELL_DN"  
#  [7] "GSE19825_NAIVE_VS_IL2RAHIGH_DAY3_EFF_CD8_TCELL_UP"                           "GSE29164_DAY3_VS_DAY7_CD8_TCELL_AND_IL12_TREATED_MELANOMA_DN"                "GSE360_DC_VS_MAC_T_GONDII_UP"                             
# [10] "GSE21379_WT_VS_SAP_KO_TFH_CD4_TCELL_UP"                                      "GSE40666_UNTREATED_VS_IFNA_STIM_EFFECTOR_CD8_TCELL_90MIN_UP"                 "GSE3203_WT_VS_IFNAR1_KO_INFLUENZA_INFECTED_LN_BCELL_DN"   
# [13] "GSE2405_HEAT_KILLED_LYSATE_VS_LIVE_A_PHAGOCYTOPHILUM_STIM_NEUTROPHIL_24H_DN" "GSE7568_CTRL_VS_3H_TGFB_TREATED_MACROPHAGES_WITH_IL4_AND_DEXAMETHASONE_UP"   "GSE13887_ACT_CD4_VS_NO_TREATED_CD4_TCELL_UP"           
# [16] "GSE2405_0H_VS_1.5H_A_PHAGOCYTOPHILUM_STIM_NEUTROPHIL_UP"

ego <- enrichGO(gene          = genes_rescued,
                universe      = genes_universe,
                OrgDb         = org.Hs.eg.db,
                keyType       = "SYMBOL", #idType(OrgDb) for available keyTypes
                ont           = "ALL",
                pAdjustMethod = "BH",
                pvalueCutoff  = 0.01,
                qvalueCutoff  = 0.05,
                readable      = TRUE)
head(ego)


# ann <- getAnnotation(IlluminaHumanMethylationEPICv2anno.20a1.hg38)

# GO pathways
GE_EV.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s"],
                   rownames(ASXL1.test.anno), 
                   "GO", "EPIC", T, anno = anno)
GE_EV.go[GE_EV.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()
GE_WT.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.res == "s"],
                   rownames(ASXL1.test.anno), 
                   "GO", "EPIC", T, anno = anno)
GE_WT.go[GE_WT.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ]
GE_rescued.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "ns"],
                        rownames(ASXL1.test.anno), 
                        "GO", "EPIC", T, anno = anno)
GE_rescued.go[GE_rescued.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()
GE_not_rescued.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "s"],
                            rownames(ASXL1.test.anno), 
                            "GO", "EPIC", T, anno = anno)
GE_not_rescued.go[GE_not_rescued.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()
GE_messed_up.go <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "ns" & ASXL1.test.anno$SD4.test.res == "s"],
                          rownames(ASXL1.test.anno), 
                          "GO", "EPIC", T, anno = anno)
GE_messed_up.go[GE_messed_up.go$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ] %>% head()

# KEGG
GE_EV.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s"],
                     rownames(ASXL1.test.anno),
                     "KEGG", "EPIC", T, anno = anno)
GE_EV.kegg[order(GE_EV.kegg$FDR), ]
GE_WT.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.res == "s"],
                   rownames(ASXL1.test.anno), 
                   "KEGG", "EPIC", T, anno = anno)
GE_WT.kegg[order(GE_WT.kegg$FDR), ]
GE_rescued.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "ns"],
                        rownames(ASXL1.test.anno), 
                        "KEGG", "EPIC", T, anno = anno)
GE_rescued.kegg[order(GE_rescued.kegg$FDR), ]
GE_not_rescued.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "s" & ASXL1.test.anno$SD4.test.res == "s"],
                            rownames(ASXL1.test.anno), 
                            "KEGG", "EPIC", T, anno = anno)
GE_not_rescued.kegg[order(GE_not_rescued.kegg$FDR), ]
GE_messed_up.kegg <- gometh(rownames(ASXL1.test.anno)[ASXL1.test.anno$SD4.test.pat == "ns" & ASXL1.test.anno$SD4.test.res == "s"],
                          rownames(ASXL1.test.anno), 
                          "KEGG", "450K", T, anno = anno)
GE_messed_up.kegg[GE_messed_up.kegg$ONTOLOGY == "BP", ] %>% .[order(.$P.DE), ]
GE_messed_up.kegg[order(GE_messed_up.kegg$FDR), ]

save(GE_EV.go, GE_WT.go, GE_rescued.go, GE_not_rescued.go, GE_messed_up.go, 
     # GE_EV.kegg, GE_WT.kegg, GE_rescued.kegg, GE_not_rescued.kegg, GE_messed_up.kegg, 
     file = "RData/904-ASXL1_Tcell_HCreference_ORA_Enrichment.RData")
```



### Permutation test

```{r}
# Compared to IQR / SD range
load("RData/907-ASXL1_Tcell_batch_corrected_t1_t2.RData")

# Set progress bar
set.seed(1234)
permTest <- function(cpg, group, group_var, n) {
    g <- unique(group)
    m0 <- mean(cpg[group == group_var]) # find the average DNAm level for group_var (in this case patient sample)
    m1 <- sapply(n, function(x) {
        ngroup <- sample(group, length(group)) # random shuffling of labels
        mean(cpg[ngroup == group_var]) # find the average DNAm level for randomly labelled samples
    })
    out <- c(sum(m0>=m1), sum(m0<=m1))
    return(out)
}
permTest2 <- function(cpg, group, group_var, n) {
    g <- unique(group)
    ord0 <- mean(order(cpg)[group == group_var]) # calculate the rank of patient sample's beta value for a given CpG (compared to HCs)
    ord0_d <- (length(group) / 2 - ord0) %>% abs() # calculate the distance from the median rank (the larger the more extreme the value is)
    ord1_d <- sapply(n, function(x) {
        ngroup <- sample(group, length(group)) # random shuffling of labels
        ord1 <- mean(order(cpg)[ngroup %in% group_var])
        ord1_d <- (length(group) / 2 - ord1) %>% abs()
        return(ord1_d)
    })
    out <- sum(ord1_d >= ord0_d) # if the shuffled (permuted) rank is rarely more extreme than the actual rank (ord0), than the patient is very different from HC
    return(out)
} 
N <- 2000
cl <- 10

# Check patient vs HC - sign test
beta.t <- beta.BC[, meta.BC$Disease_Status != "Patient_WT"]
meta.t <- meta.BC[colnames(beta.t), ]
permOut.EV <- pbapply(beta.t, 1, function(x) permTest(x, meta.t$Disease_Status, "Patient_EV", 1:N), cl = cl) %>% t() %>% as.data.frame()
permOut.EV <- permOut.EV/N
colnames(permOut.EV) <- c("Hypo_pval", "Hyper_pval")
permOut.EV$Hypo_qval <- p.adjust(permOut.EV$Hypo_pval)
permOut.EV$Hyper_qval <- p.adjust(permOut.EV$Hyper_pval)

# Check rescue vs HC - sign test
beta.t <- beta.BC[, meta.BC$Disease_Status != "Patient_EV"]
meta.t <- meta.BC[colnames(beta.t), ]
permOut.WT <- pbapply(beta.t, 1, function(x) permTest(x, meta.t$Disease_Status, "Patient_WT", 1:N), cl = cl) %>% t() %>% as.data.frame()
permOut.WT <- permOut.WT/N
colnames(permOut.WT) <- c("Hypo_pval", "Hyper_pval")
permOut.WT$Hypo_qval <- p.adjust(permOut.WT$Hypo_pval)
permOut.WT$Hyper_qval <- p.adjust(permOut.WT$Hyper_pval)

save(permOut.EV, permOut.WT, file = "RData/908-ASXL1_Tcell_permutation_sign_test_t1_t2.RData")

# Check patient vs HC - Modified rank sum test
beta.t <- beta.BC[, meta.BC$Disease_Status != "Patient_WT"]
meta.t <- meta.BC[colnames(beta.t), ]
permOut.EV2 <- pbapply(beta.t, 1, function(x) permTest2(x, meta.t$Disease_Status, "Patient_EV", 1:N), cl = cl) 
deltaB <- beta.t[, meta.t$Disease_Status == "Patient_EV"] - rowMeans(beta.t[, meta.t$Disease_Status != "Patient_EV"])
permOut.EV2 <- cbind(deltaB = deltaB, pval = permOut.EV2/N) %>% as.data.frame()
permOut.EV2$qval <- p.adjust(permOut.EV2$pval)
 
# Check rescue vs HC - Modified rank sum test
beta.t <- beta.BC[, meta.BC$Disease_Status != "Patient_EV"]
meta.t <- meta.BC[colnames(beta.t), ]
permOut.WT2 <- pbapply(beta.t, 1, function(x) permTest2(x, meta.t$Disease_Status, "Patient_WT", 1:N), cl = cl) 
deltaB <- beta.t[, meta.t$Disease_Status == "Patient_WT"] - rowMeans(beta.t[, meta.t$Disease_Status != "Patient_WT"])
permOut.WT2 <- cbind(deltaB = deltaB, pval = permOut.WT2/N) %>% as.data.frame()
permOut.WT2$qval <- p.adjust(permOut.WT2$pval)

save(permOut.EV2, permOut.WT2, file = "RData/908-ASXL1_Tcell_permutation_ranksum_test_t1_t2.RData")

# Check overlap
cutoff <- 0.05 # Likelihood for patient sample to get picked
test.hyper <- intersect(rownames(permOut.EV)[permOut.EV$Hyper_qval < cutoff], rownames(permOut.WT)[permOut.WT$Hyper_pval < cutoff]) # 77 vs 0
test.hypo <- intersect(rownames(permOut.EV)[permOut.EV$Hypo_pval < cutoff], rownames(permOut.WT)[permOut.WT$Hypo_pval < cutoff]) # 207 vs 0
# test2.hyper <- intersect(rownames(permOut2.pat)[permOut2.pat$Hyper_pval < cutoff], rownames(permOut2.res)[permOut2.res$Hyper_pval < cutoff]) # 28 / 185
# test2.hypo <- intersect(rownames(permOut2.pat)[permOut2.pat$Hypo_pval < cutoff], rownames(permOut2.res)[permOut2.res$Hypo_pval < cutoff]) # 28 / 185
length(rownames(permOut.EV)[permOut.EV$Hyper_pval < cutoff]) # 48515
length(rownames(permOut.EV)[permOut.EV$Hypo_pval < cutoff]) # 137860
length(rownames(permOut.WT)[permOut.WT$Hyper_pval < cutoff]) # 94067
length(rownames(permOut.WT)[permOut.WT$Hypo_pval < cutoff]) # 76163
length(intersect(rownames(permOut2.pat)[permOut2.pat$pval < cutoff], rownames(permOut2.res)[permOut2.res$pval < cutoff]))

# Make heatmap
plt.hyper <- beta[rownames(permOut.EV)[permOut.EV$Hyper_pval < cutoff], ] %>% 
    .[.]
plt.hypo <- beta[rownames(permOut.EV)[permOut.EV$Hypo_pval < cutoff], ]
pheatmap(plt.hyper, show_rownames = F, scale = "row", treeheight_row = 0)
pheatmap(plt.hypo[sample(1:nrow(plt.hypo), 50000), ], show_rownames = F, scale = "row", treeheight_row = 0)

plt.hyper <- beta[rownames(permOut.WT)[permOut.WT$Hyper_pval < cutoff], ]
plt.hypo <- beta[rownames(permOut.WT)[permOut.WT$Hypo_pval < cutoff], ]
pheatmap(plt.hyper[sample(1:nrow(plt.hypo), 50000), ], show_rownames = F, scale = "row", treeheight_row = 0)
pheatmap(plt.hypo[sample(1:nrow(plt.hypo), 50000), ], show_rownames = F, scale = "row", treeheight_row = 0)

pheatmap(rbind(plt.hyper, plt.hypo), show_rownames = F, scale = "row")
```

#### Enrichment Analysis - preranked GSEA

```{r}
# Genes involved in the hits

# Enrichment analysis
```

### RLM

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")

beta <- beta.noxy
meta <- meta.noxy

# Check rescue vs HC 
beta.t <- beta[, meta$Disease_Status != "Patient_WT" & meta$Time_Point == "T2"] # 
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- gsub("HC_EV", "0", meta.t$Disease_Status) %>% 
    gsub("Patient_EV", "1", .) %>%
    as.numeric()
rlmOut.EV <- sapply(1:nrow(beta.t), function(x){
    out <- rlm(beta.t[x,] ~ Disease_Status +  predictedSex + Age + Slide + Sentrix_Row + CD8_perc_flow, 
               data = meta.t, psi = psi.huber)
    pvalue <- f.robftest(out, var = names(out$coefficients)[2])$p.value
    coef <- summary(out)$coefficients[2,1]
    tvalue <- summary(out)$coefficients[2,3]
    stderror <- summary(out)$coefficients[2,2]
    CpG <- rownames(beta.t)[x]
    return(c(CpG, pvalue, coef, tvalue, stderror))
}) %>% t() %>% as.data.frame()
colnames(rlmOut.EV) <- c("CpG", "Pval", "Coef", "Tval", "StdError")
rlmOut.EV[, 2:5] <- sapply(rlmOut.EV[, 2:5], as.numeric)
rlmOut.EV$AdjPval <- p.adjust(rlmOut.EV$Pval, "BH")
hist(rlmOut.EV$Pval)

# Check WT ASXL1 vs HC - Limma
beta.t <- beta[, meta$Disease_Status != "Patient_EV" & meta$Time_Point == "T2"] # & meta$Time_Point == "T2"
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- gsub("HC_EV", "0", meta.t$Disease_Status) %>% 
    gsub("Patient_WT", "1", .) %>%
    as.numeric()
rlmOut.WT <- sapply(1:nrow(beta.t), function(x){
    out <- rlm(beta.t[x,] ~ Disease_Status +  predictedSex + Age + Slide + Sentrix_Row + CD8_perc_flow, 
               data = meta.t, psi = psi.huber)
    pvalue <- f.robftest(out, var = names(out$coefficients)[2])$p.value
    coef <- summary(out)$coefficients[2,1]
    tvalue <- summary(out)$coefficients[2,3]
    stderror <- summary(out)$coefficients[2,2]
    CpG <- rownames(beta.t)[x]
    return(c(CpG, pvalue, coef, tvalue, stderror))
}) %>% t() %>% as.data.frame()
colnames(rlmOut.WT) <- c("CpG", "Pval", "Coef", "Tval", "StdError")
rlmOut.WT[, 2:5] <- sapply(rlmOut.WT[, 2:5], as.numeric)
rlmOut.WT$AdjPval <- p.adjust(rlmOut.WT$Pval, "BH")
hist(rlmOut.WT$Pval)

save(rlmOut.EV, rlmOut.WT, file = "RData/908-ASXL1_Tcell_RLM_test_ct_adjusted_t2.RData")
```

##### Volcano Plot

```{r}
### Volcano plot
source("../../Functions/makeVolcano2.R")
load("RData/908-ASXL1_Tcell_RLM_test_ct_adjusted_t2.RData")

rlmOut.EV <- rlmOut.EV[!is.na(rlmOut.EV$Pval), ]
rlmOut.WT <- rlmOut.WT[!is.na(rlmOut.WT$Pval), ]

makeVolcano2(name = rlmOut.EV$CpG, 
             pvalue = rlmOut.EV$Pval, 
             deltabeta = rlmOut.EV$Coef, 
             ymax = 80, 
             alpha = 0.8, 
             palette = 3, 
             dB_threshold = 0.1, 
             pval_threshold = 0.05, #0.022 (no CT), 0.0316(CD8)
             adjusted = F, xmin = -5, xmax = 5)
makeVolcano2(name = rlmOut.WT$CpG, 
             pvalue = rlmOut.WT$Pval, 
             deltabeta = rlmOut.WT$Coef, 
             ymax = 10, 
             alpha = 0.8, 
             palette = 3, 
             dB_threshold = 0.1, 
             pval_threshold = 0.05, 
             adjusted = F)
```

### Limma

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")

# load("RData/907-ASXL1_Tcell_batch_corrected_t1_t2.RData")

# beta <- adj.residuals
beta <- beta.noxy
meta <- meta.noxy
anno <- anno.noxy


# Check patient vs HC - Limma
beta.t <- beta[, meta$Disease_Status != "Patient_WT" & meta$Time_Point == "T2"] # 
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- gsub("HC_EV", "0", meta.t$Disease_Status) %>% 
    gsub("Patient_EV", "1", .) %>%
    as.numeric()

design <- model.matrix(~Disease_Status + predictedSex + Age + Slide + Sentrix_Row + CD8_perc_flow, data = meta.t) # + CD8_perc_flow
fit1 <- lmFit(beta.t, design)
fit1 <- eBayes(fit1)
limmaOut <- topTable(fit1, coef = 2, adjust = "BH", number = nrow(beta.t))
limmaOut.EV <- merge(limmaOut, anno[, c("CHR", "MAPINFO", "UCSC_REFGENE_NAME", "GENCODEV41_NAME")], by = 0) %>%
    .[order(.$P.Value, decreasing = F), ] 
rownames(limmaOut.EV) <- as.character(limmaOut.EV$Row.names)
hist(limmaOut.EV$P.Value)
sum(limmaOut.EV$P.Value < 1e-5) #41759, 17
sum(limmaOut.EV$adj.P.Val < 0.2) #393775, 141113
sum(limmaOut.EV$logFC > 0.1 & limmaOut.EV$adj.P.Val < 0.2) #30195, 12009
sum(limmaOut.EV$logFC < -0.1 & limmaOut.EV$adj.P.Val < 0.2) #333812, 129104

# Check WT ASXL1 vs HC - Limma
beta.t <- beta[, meta$Disease_Status != "Patient_EV" & meta$Time_Point == "T2"] # & meta$Time_Point == "T2"
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- gsub("HC_EV", "0", meta.t$Disease_Status) %>% 
    gsub("Patient_WT", "1", .) %>%
    as.numeric()

design <- model.matrix(~Disease_Status + predictedSex + Age + Slide + Sentrix_Row + CD4_perc_flow, data = meta.t) # + CD8_perc_flow
fit <- lmFit(beta.t, design)
fit <- eBayes(fit)
limmaOut <- topTable(fit, coef = 2, adjust = "BH", number = nrow(beta.t))
limmaOut.WT <- merge(limmaOut, anno[, c("CHR", "MAPINFO", "UCSC_REFGENE_NAME", "GENCODEV41_NAME")], by = 0) %>%
    .[order(.$P.Value, decreasing = F), ]
rownames(limmaOut.WT) <- as.character(limmaOut.WT$Row.names)
hist(limmaOut.WT$P.Value)
sum(limmaOut.WT$P.Value < 1e-5) # 13750, 1
sum(limmaOut.WT$adj.P.Val < 0.2) # 354379, 35457
sum(limmaOut.WT$logFC > 0.1 & limmaOut.WT$adj.P.Val < 0.2) #21571, 2211
sum(limmaOut.WT$logFC < -0.1 & limmaOut.WT$adj.P.Val < 0.2) #293607, 33246

# Calculate effect size



# Save results
save(limmaOut.EV, limmaOut.WT, file = "RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")
save(limmaOut.EV, limmaOut.WT, file = "RData/908-ASXL1_Tcell_limma_test_t2.RData")
```

#### Check Skewness

```{r}
library(normtest)

skewness.norm.test(limmaOut.EV$logFC)
skewness.norm.test(limmaOut.WT$logFC)
```


#### Plotting Limma's hits

```{r}
load("RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")
load("RData/908-ASXL1_Tcell_limma_test_t2.RData")

load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")
load("RData/906-ASXL1_Tcell_betas_flowct_adjusted_noxy_t1_t2.RData")

# beta <- adj.residuals

beta.t <- beta.noxy %>%
    .[,  c("HC1_T2", "HC2_T2", "HC3_T2", "Dad_T2", "Mom_T2", "Sister_T2", "P1_T2", "P2_T2", "P3_T2", "R1_T2", "R2_T2", "R3_T2")] 
    # .[,  c("HC1_T1", "HC1_T2", "HC2_T1", "HC2_T2", "HC3_T1", "HC3_T2", "Dad_T1", "Dad_T2", "Mom_T1", "Mom_T2", "Sister_T1", "Sister_T2", "P_T1", "P1_T2", "P2_T2", "P3_T2", "R_T1", "R1_T2", "R2_T2", "R3_T2")] 
meta.t <- meta.noxy %>% 
    .[colnames(beta.t), ]

cutoff.pv <- 0.2
cutoff.db <- 0.1

dim(limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff.pv & abs(limmaOut.EV$logFC) >= cutoff.db, ])
dim(limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff.pv & abs(limmaOut.WT$logFC) >= cutoff.db, ])

plt <- beta.t[rownames(limmaHits.EV), ] %>% 
    .[sample(rownames(.), 20000), ]
    # using the SD5 definition
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering

plt <- beta.t[rownames(limmaHits.WT), ] %>% 
    .[sample(rownames(.), 20000), ]
    # using the SD5 definition
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering

plt <- beta[limmaOut.shared, ] #%>% 
    # .[order(.[, "P_EV"]), ] 
    # using the SD5 definition
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "row", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
pheatmap(plt, # cannot plot all 
         show_rownames = F, 
         scale = "none", 
         treeheight_row = 0, 
         cluster_cols = F,
         cluster_rows = T) # do not show clustering
```

##### Volcano Plot

```{r}
### Volcano plot
source("../../Functions/makeVolcano2.R")
load("RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")
load("RData/908-ASXL1_Tcell_limma_test_t2.RData")

makeVolcano2(name = rownames(limmaOut.EV), 
             pvalue = limmaOut.EV$P.Value, 
             deltabeta = limmaOut.EV$logFC, 
             ymax = 10, 
             xmin = -3, 
             xmax = 3,
             alpha = 0.8, 
             palette = 3, 
             dB_threshold = 0.1, 
             pval_threshold = 0.0316, #0.022 (no CT), 0.0316(CD8)
             adjusted = F)
makeVolcano2(name = rownames(limmaOut.WT), 
             pvalue = limmaOut.WT$P.Value, 
             deltabeta = limmaOut.WT$logFC, 
             ymax = 10, 
             xmin = -2, 
             xmax = 2,
             alpha = 0.8, 
             palette = 3, 
             dB_threshold = 0.1, 
             pval_threshold = 0.02, 
             adjusted = F)
```

#### Examine overlap of EV and Rescue

```{r}
load("RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")
load("RData/908-ASXL1_Tcell_limma_test_t2.RData")

cutoff.pv <- 0.05
cutoff.db <- 0.1

# Subset to hits
limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff.pv & abs(limmaOut.EV$logFC) >= cutoff.db, ]
limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff.pv & abs(limmaOut.WT$logFC) >= cutoff.db, ]

# refHits.EV <- refOut[refOut$SD5.test.pat == "s", ]
# refHits.WT <- refOut[refOut$SD5.test.res == "s", ]
# permHits.EV <- permOut.EV[permOut.EV$Hypo_pval < 1/7 | permOut.EV$Hyper_pval < 1/7, ]
# permHits.WT <- permOut.WT[permOut.WT$Hypo_pval < 1/7 | permOut.WT$Hyper_pval < 1/7, ]

# Make Venn Diagram

group.colors <- c("family control" = "#F9791EFF", "unrelated healthy control" = "#5E81ACFF", "patient_WT" ="#44AA99", "patient_EV" = "#403369FF")
group.colors <- c("EV" ="#403369FF", "WT" = "#44AA99")
limmaHits.O <- list(EV = rownames(limmaHits.EV),
                    WT = rownames(limmaHits.WT))

ggvenn(limmaHits.O,
       fill_color = c("#403369FF", "#44AA99"),
       stroke_size = 0.5, 
       set_name_size = 4, 
       fill_alpha = 0.7, 
       auto_scale = T)


```


#### Enrichment analysis on Limma's result

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_t1_t2.RData")
load("RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")

cutoff.pv <- 0.2
cutoff.db <- 0.1

# Subset to hits
limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff.pv & abs(limmaOut.EV$logFC) >= cutoff.db, ]
limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff.pv & abs(limmaOut.WT$logFC) >= cutoff.db, ]


genes_EV <- limmaHits.EV$UCSC_REFGENE_NAME %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_EV_up <- limmaHits.EV$UCSC_REFGENE_NAME[limmaHits.EV$logFC > 0] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_EV_down <- limmaHits.EV$UCSC_REFGENE_NAME[limmaHits.EV$logFC < 0] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]

genes_WT <- limmaHits.WT$UCSC_REFGENE_NAME %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_WT_up <- limmaHits.WT$UCSC_REFGENE_NAME[limmaHits.WT$logFC > 0] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]
genes_WT_down <- limmaHits.WT$UCSC_REFGENE_NAME[limmaHits.WT$logFC < 0] %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""]


# Background genes measured on the array
genes_universe <- anno$UCSC_REFGENE_NAME %>% 
    strsplit2(., ";") %>%
    as.vector() %>%
    unique() %>%
    .[. != ""] 

# Hallmark enrichment - want to check IL2-STAT5 pathway
h_gene_sets <- msigdbr(species = "human", category = "H")
msigdbr_t2g <- h_gene_sets %>% 
    dplyr::distinct(gs_name, gene_symbol) %>% 
    as.data.frame 
(pathway_EV <- enricher(gene = genes_EV, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION" "HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_KRAS_SIGNALING_DN" "HALLMARK_HEDGEHOG_SIGNALING" "HALLMARK_COAGULATION" "HALLMARK_NOTCH_SIGNALING" 
(pathway_EV_up <- enricher(gene = genes_EV_up, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_ESTROGEN_RESPONSE_EARLY" "HALLMARK_KRAS_SIGNALING_DN" "HALLMARK_APICAL_JUNCTION"                   "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_WNT_BETA_CATENIN_SIGNALING" "HALLMARK_ANGIOGENESIS" "HALLMARK_UV_RESPONSE_DN" "HALLMARK_ESTROGEN_RESPONSE_LATE" "HALLMARK_NOTCH_SIGNALING"
(pathway_EV_down <- enricher(gene = genes_EV_down, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS" "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_COAGULATION" "HALLMARK_APICAL_SURFACE"

(pathway_WT <- enricher(gene = genes_WT, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #  "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION"
(pathway_WT_up <- enricher(gene = genes_WT_up, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_UV_RESPONSE_DN"
(pathway_WT_down <- enricher(gene = genes_EV_down, TERM2GENE = msigdbr_t2g, universe = genes_universe)) #"HALLMARK_MYOGENESIS"  "HALLMARK_UV_RESPONSE_DN" "HALLMARK_APICAL_JUNCTION" "HALLMARK_EPITHELIAL_MESENCHYMAL_TRANSITION" "HALLMARK_COAGULATION" "HALLMARK_APICAL_SURFACE"

# Plot enrichment
pathway_EV <- pathway_EV@result
pathway_EV$log10Padj <- log10(pathway_EV$p.adjust)*-1
ggplot(pathway_EV[pathway_EV$p.adjust < 0.05, ], aes(reorder(ID, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "")
pathway_WT <- pathway_WT@result
pathway_WT$log10Padj <- log10(pathway_WT$p.adjust)*-1
ggplot(pathway_WT[pathway_WT$p.adjust < 0.05, ], aes(reorder(ID, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "")
```

##### Preranked GSEA - fgsea

```{r}
# Preranked GSEA
# h_gene_sets_fgsea <- lapply(h_gene_sets$)
limmaRank.EV <- limmaOut.EV$t
names(limmaRank.EV) <- as.character(limmaOut.EV$Row.names)
```

##### GO enrichment - missMethyl

```{r}
anno <- readRDS("../../Reference/EPICv2_fdat.rds")

# anno$UCSC_RefGene_Name <- anno$UCSC_REFGENE_NAME
# anno$UCSC_RefGene_Group <- anno$UCSC_REFGENE_GROUP
# missMethyl GO enrichment
GE_EV.go <- gometh(rownames(limmaHits.EV),
                   rownames(limmaOut.EV), 
                   "GO", "EPIC", 
                   plot.bias = TRUE, 
                   prior.prob = TRUE, 
                   anno = anno)
plt <- GE_EV.go %>% .[order(.$P.DE), ] %>% .[.$ONTOLOGY %in% c("BP", "MF"), ]
head(plt)
plt$log10Padj <- log10(plt$FDR)*-1
ggplot(plt[1:30, ], aes(reorder(TERM, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "GO Gene Set Enrichment")

GE_EV.kegg <- gometh(rownames(limmaHits.EV),
                     rownames(limmaOut.EV),
                     "KEGG", "EPIC", T, anno = anno)
plt <- GE_EV.kegg %>% .[order(.$P.DE), ]
head(plt)
plt$log10Padj <- log10(plt$FDR)*-1
ggplot(plt[1:20, ], aes(reorder(TERM, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "GO Gene Set Enrichment")


GE_WT.go <- gometh(rownames(limmaHits.WT),
                   rownames(limmaOut.WT), 
                   "GO", "EPIC", 
                   plot.bias = TRUE, 
                   prior.prob = TRUE, 
                   anno = anno)
plt <- GE_WT.go %>% .[order(.$P.DE), ] %>% .[.$ONTOLOGY %in% c("BP", "MF"), ]

plt$log10Padj <- log10(plt$FDR)*-1
ggplot(plt[1:20, ], aes(reorder(TERM, log10Padj), log10Padj)) + geom_bar(stat = "identity") + coord_flip() + theme_bw() + labs(y = "Adjusted P-value (-log10)", x = "GO Gene Set Enrichment")
```

##### ChromHMM enrichment - missMethyl

```{r}
# load("RData/907-ASXL1_Tcell_batch_corrected_t1_t2_NOT_CT_corrected.RData")
load("RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")
anno <- readRDS("../../Reference/EPICv2_fdat.rds")

### ChromHMM (thank you Nicole for all the code and creating the annotation file)
load("~/shared_coding_resource/ChromeHMM_Data/EPIC_Anno_ChromeHMM.RData")
Chrom_df <- EPIC_Anno_ChromeHMM[rownames(EPIC_Anno_ChromeHMM) %in% rownames(limmaOut.EV), c("Name", "E034_TCells_State")]
colnames(Chrom_df) <- c("Probe_ID", "region")

# anno$UCSC_RefGene_Name <- anno$UCSC_REFGENE_NAME
# anno$UCSC_RefGene_Group <- anno$UCSC_REFGENE_GROUP
ChromHMMset <- lapply(unique(Chrom_df$region), function(x){
    cpgs <- Chrom_df$Probe_ID[Chrom_df$region == x]
    id <- getMappedEntrezIDs(cpgs, array.type = "EPIC", anno = anno)
    return(id$sig.eg)
})
names(ChromHMMset) <- unique(Chrom_df$region)

cutoff.pv <- 0.2
cutoff.db <- 0.1

# Subset to hits
limmaHits.EV <- limmaOut.EV[limmaOut.EV$adj.P.Val <= cutoff.pv & abs(limmaOut.EV$logFC) >= cutoff.db, ]
limmaHits.WT <- limmaOut.WT[limmaOut.WT$adj.P.Val <= cutoff.pv & abs(limmaOut.WT$logFC) >= cutoff.db, ]
pathChromHMM.EV <- gsameth(sig.cpg = rownames(limmaHits.EV), 
                           all.cpg = rownames(limmaOut.EV), 
                           collection = ChromHMMset, 
                           array.type = "EPIC", 
                           anno = anno) %>% .[order(.$FDR), ]
pathChromHMM.EV$Term <- rownames(pathChromHMM.EV) %>% 
    gsub("1_TssA", "Active TSS", .) %>%
    gsub("2_TssFlnk", "Flanking TSS", .) %>% 
    gsub("3_TssFlnkU", "Flanking TSS Upstream", .) %>% 
    gsub("4_TssFlnkD", "Flanking TSS Downstream", .) %>% 
    gsub("5_Tx", "Strong Transcription", .) %>% 
    gsub("6_TxWk", "Weak Transcription", .) %>% 
    gsub("7_EnhG1", "Genic Enhancer 1", .) %>% 
    gsub("8_EnhG2", "Genic Enhancer 2", .) %>% 
    gsub("9_EnhA1", "Active Enhancer 1", .) %>% 
    gsub("10_EnhA2", "Active Enhancer 2", .) %>% 
    gsub("11_EnhWk", "Weak Enhancer", .) %>% 
    gsub("12_ZNF/Rpts", "ZNF genes & repeats", .) %>% 
    gsub("13_Het", "Heterochromatin", .) %>% 
    gsub("14_TssBiv", "Bivalent/Poised TSS", .) %>% 
    gsub("15_EnhBiv", "Bivalent Enhancer", .) %>% 
    gsub("16_ReprPC", "Repressed PolyComb", .) %>% 
    gsub("17_ReprPCWk", "Weak Repressed PolyComb", .) %>% 
    gsub("18_Quies", "Quiescent/Low", .) 
pathChromHMM.EV$log10Padj <- log10(pathChromHMM.EV$FDR)*-1


pathChromHMM.WT <- gsameth(sig.cpg = rownames(limmaHits.WT), 
                           all.cpg = rownames(limmaOut.WT), 
                           collection = ChromHMMset, 
                           array.type = "EPIC", 
                           anno = anno) %>% .[order(.$FDR), ]
pathChromHMM.WT$Term <- rownames(pathChromHMM.WT) %>% 
    gsub("1_TssA", "Active TSS", .) %>%
    gsub("2_TssFlnk", "Flanking TSS", .) %>% 
    gsub("3_TssFlnkU", "Flanking TSS Upstream", .) %>% 
    gsub("4_TssFlnkD", "Flanking TSS Downstream", .) %>% 
    gsub("5_Tx", "Strong Transcription", .) %>% 
    gsub("6_TxWk", "Weak Transcription", .) %>% 
    gsub("7_EnhG1", "Genic Enhancer 1", .) %>% 
    gsub("8_EnhG2", "Genic Enhancer 2", .) %>% 
    gsub("9_EnhA1", "Active Enhancer 1", .) %>% 
    gsub("10_EnhA2", "Active Enhancer 2", .) %>% 
    gsub("11_EnhWk", "Weak Enhancer", .) %>% 
    gsub("12_ZNF/Rpts", "ZNF genes & repeats", .) %>% 
    gsub("13_Het", "Heterochromatin", .) %>% 
    gsub("14_TssBiv", "Bivalent/Poised TSS", .) %>% 
    gsub("15_EnhBiv", "Bivalent Enhancer", .) %>% 
    gsub("16_ReprPC", "Repressed PolyComb", .) %>% 
    gsub("17_ReprPCWk", "Weak Repressed PolyComb", .) %>% 
    gsub("18_Quies", "Quiescent/Low", .) 
pathChromHMM.WT$log10Padj <- log10(pathChromHMM.WT$FDR)*-1

plt <- pathChromHMM.EV
ggplot(plt, aes(reorder(Term, log10Padj), log10Padj)) + 
    geom_bar(stat = "identity") + 
    labs(y = "Adjusted P-value (-log10)", x = "ChromHMM 18 States Annotation in T-cells") + 
    geom_hline(yintercept = log10(0.01)*-1, linetype = 'dashed', color = "gray") +
    coord_flip() + 
    theme_bw() + 
    theme(text = element_text(size = 13)) + 
    ylim(0, 180)


pathChromHMM.EV$Term <- factor(pathChromHMM.EV$Term, levels = pathChromHMM.EV$Term[order(pathChromHMM.EV$log10Padj, decreasing = F)])
pathChromHMM.WT$Term <- factor(pathChromHMM.WT$Term, levels = pathChromHMM.EV$Term[order(pathChromHMM.EV$log10Padj, decreasing = F)])
# Plot the barplots together
group.colors <- c("family control" = "#F9791EFF", "unrelated healthy control" = "#5E81ACFF", "patient_WT" ="#44AA99", "patient_EV" = "#403369FF")
test <- ggplot(mapping = aes(Term, log10Padj)) +
    geom_bar(data = pathChromHMM.EV, width = 0.8, stat = 'identity', fill = "#403369FF", alpha = 0.8) +
    geom_bar(data = pathChromHMM.WT, width = 0.8, stat = 'identity', fill = "#44AA99", alpha = 0.8) +
    # scale_y_continuous(expand = c(0, 0)) + 
    labs(y = "Adjusted P-value (-log10)", x = "ChromHMM 18 States Annotation in T-cells") + 
    geom_hline(yintercept = log10(0.01)*-1, linetype = 'dashed', color = "gray") +
    coord_flip() + 
    theme_bw() + 
    theme(text = element_text(size = 13)) + 
    ylim(0, 180)
cvd_grid(test)
```


### Examine overlap

```{r}
refOut <- readRDS("RData/903-ASXL1_Tcell_global_test.rds")
load("RData/903-ASXL1_Tcell_permutation_sign_test.RData")
load("RData/903-ASXL1_Tcell_limma_test.RData")

# Subset to hits
limmaHits.EV <- limmaOut.EV
limmaHits.WT <- limmaOut.WT
refHits.EV <- refOut[refOut$SD5.test.pat == "s", ]
refHits.WT <- refOut[refOut$SD5.test.res == "s", ]
permHits.EV <- permOut.EV[permOut.EV$Hypo_pval < 1/7 | permOut.EV$Hyper_pval < 1/7, ]
permHits.WT <- permOut.WT[permOut.WT$Hypo_pval < 1/7 | permOut.WT$Hyper_pval < 1/7, ]

# Make Venn Diagram
allHits.EV <- list(Outlier_test = rownames(refHits.EV),
                   Permutation_test = rownames(permHits.EV),
                   Limma_test = as.character(limmaHits.EV$Row.names))
allHits.WT <- list(Outlier_test = rownames(refHits.WT),
                   Permutation_test = rownames(permHits.WT),
                   Limma_test = as.character(limmaHits.WT$Row.names))

plot(euler(allHits.EV, shape = "ellipse"), quantities = TRUE)
plot(euler(allHits.WT, shape = "ellipse"), quantities = TRUE)

ggvenn(allHits.EV,
       fill_color = c("#7890A8", "#A8A8A8", "#6A7E4F"),
       stroke_size = 0.5, 
       set_name_size = 4, 
       fill_alpha = 0.7)

ggvenn(allHits.WT,
       fill_color = c("#7890A8", "#A8A8A8", "#6A7E4F"),
       stroke_size = 0.5, 
       set_name_size = 4, 
       fill_alpha = 0.7)
```

## CT-Specific Differential DNAm

```{r}
.libPaths()
# .libPaths("/mnt/scratch/KoborLab/R/x86_64-pc-linux-gnu-library/4.2")
library(doParallel)
cl <- makeCluster(8)
registerDoParallel(cl)
clusterEvalQ(cl, library(doParallel))
# stopCluster(cl)


load("RData/907-ASXL1_Tcell_batch_corrected_n3.RData")
beta <- beta.BC

beta.t <- beta.BC[, meta$Sample_Group != "patient_WT"]
meta.t <- meta[colnames(beta.t), ]
meta.t$Disease_Status <- factor(meta.t$Disease_Status, levels = c("HC", "Patient_EV"))
ct <- meta.t[, c("CD8_perc_DNAm", "CD4_perc_DNAm"), drop = F] #  proportions are too low and removed
pheno1 <- meta.t[, c("Disease_Status", "Age"), drop = F]
pheno2 <- meta.t[, c("predictedSex"), drop = F]
# test <- pheno1
# test$Disease_Status <- c(rep("Healthy", 30), rep("Sick", (nrow(test) - 30)))
library(caret)
# test <- upSample(x = t(beta.t),
#                  y = meta.t$Disease_Status)    
library(TOAST)
res_cedar2 <- cedar(Y_raw = beta.t[1:200, ],
                    prop = ct,
                    design.1 = pheno1,
                    design.2 = pheno2,
                    factor.to.test = 'Disease_Status',
                    parallel.core = 8)

save(res_cedar2, file = "RData/913-Cedar_ct_specific_DMs.RData")

library(TCA)
ct[ct < 0] <- 0 #If necessary, add the offset of 0.001
ct <- apply(ct, 1, function(x) x / sum(x)) %>% 
    t() %>%
    as.data.frame()
pheno1 <- model.matrix(~Disease_Status + Age, data = meta.t) %>% .[, -1, drop = F]
pheno2 <- model.matrix(~predictedSex, data = meta.t) %>% .[, -1, drop = F]
tca_output <- tca(X = beta.t,
                  W = ct,
                  C1 = pheno1,
                  C2 = pheno2)
# Extract CpG-level p-values for the association with disease status, under a joint test
tca.DS.pvals.joint <- tca_output$gammas_hat_pvals.joint[, 1]
# Extract p-values for each cell type for its association with disease status, under a marginal conditional test
tca.DS.pvals.marg_cond <- 
  tca_output$gammas_hat_pvals[,paste(colnames(ct),".Disease_StatusPatient_EV", sep = "")]  
# qq-plots - for the p-values of the joint test, and for the marginal conditional p-values for CD4 cells
plot_qq(list(tca.DS.pvals.joint, tca.DS.pvals.marg_cond[, 2]),
        labels = c("Joint test with disease status", 
                   "CD8 marginal conditional test with disease status"),
        ggarrange.nrow = 1,
        ggarrange.ncol = 2,
        experiment_wide_line = FALSE)

library(EpiDISH)
pheno1 <- model.matrix(~Disease_Status, data = meta.t) %>% .[, -1, drop = F]
pheno2 <- model.matrix(~Age + predictedSex, data = meta.t) %>% .[, -1, drop = F]
dmc_output <- CellDMC(beta.m = beta.t[1:10000, ], 
                      pheno.v = pheno1, 
                      frac.m = as.matrix(ct), 
                      cov.mod = pheno2)
dmc_output$coe$CD8_perc_DNAm
```

## For GEO submission

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")

beta <- beta.noxy[, meta.noxy$Time_Point == "T2"]
meta <- meta.noxy[colnames(beta), ]
beta <- beta[, c("P1_T2", "P2_T2", "P3_T2", "R1_T2", "R2_T2", "R3_T2", "Sister_T2", "Mom_T2", "Dad_T2", "HC1_T2", "HC2_T2", "HC3_T2")]
meta <- meta[c("P1_T2", "P2_T2", "P3_T2", "R1_T2", "R2_T2", "R3_T2", "Sister_T2", "Mom_T2", "Dad_T2", "HC1_T2", "HC2_T2", "HC3_T2"), ]
colnames(beta) <- c("Tcells_P_rep1", "Tcells_P_rep2", "Tcells_P_rep3", "Tcells_R_rep1", "Tcells_R_rep2", "Tcells_R_rep3", "Tcells_Sister", "Tcells_Mom", "Tcells_Dad", "Tcells_HC1", "Tcells_HC2", "Tcells_HC3")
rownames(meta) <- c("Tcells_P_rep1", "Tcells_P_rep2", "Tcells_P_rep3", "Tcells_R_rep1", "Tcells_R_rep2", "Tcells_R_rep3", "Tcells_Sister", "Tcells_Mom", "Tcells_Dad", "Tcells_HC1", "Tcells_HC2", "Tcells_HC3")
meta$Sample_Name <- rownames(meta)

rgset <- readRDS("RData/905-ASXL1_Tcell_RGset_n3.rds")
detP <- minfi::detectionP(as(RGset, "RGChannelSet")) 
Mset <- preprocessRaw(RGset)
meth <- getMeth(Mset)
unmeth <- getUnmeth(Mset)

write.csv(meta, file = "GEO_submission/GEO_submission_ASXL1_Tcell_meta.csv")
write.csv(beta, file = "GEO_submission/GEO_submission_ASXL1_Tcell_normed_beta.csv")
write.csv(detP, file = "GEO_submission/GEO_submission_ASXL1_Tcell_detectionP.csv")
write.csv(meth, file = "GEO_submission/GEO_submission_ASXL1_Tcell_meth_intensity.csv")
write.csv(unmeth, file = "GEO_submission/GEO_submission_ASXL1_Tcell_unmeth_intensity.csv")
```

## Check NCAM1 / IL4 / Other specific genes

```{r}
load("RData/906-ASXL1_Tcell_betas_norm_noxy_t1_t2.RData")
load("RData/908-ASXL1_Tcell_limma_test_ct_adjusted_t2.RData")
# load("RData/907-ASXL1_Tcell_batch_corrected_t1_t2.RData")

# beta <- adj.residuals
beta <- beta.noxy
meta <- meta.noxy
anno <- anno.noxy

# Check patient vs HC - Limma
beta.t <- beta[, meta$Time_Point == "T2"] # 
meta.t <- meta[colnames(beta.t), ]
cpgs <- rownames(anno)[grep("NCAM1", anno$UCSC_REFGENE_NAME)]
plt <- beta.t[cpgs, c("HC1_T2", "HC3_T2", "HC2_T2", "Dad_T2", "Sister_T2", "Mom_T2", "P1_T2", "P2_T2", "P3_T2", "R1_T2", "R2_T2", "R3_T2")] %>%
    as.data.frame(.)
plt$mapinfo <- anno[cpgs, "MAPINFO"]
plt$Padj <- limmaOut.EV[cpgs, "adj.P.Val"]
# plt$star <- apply(plt, 1, function(x) {
#     if(x["Padj"] < 0.2) {
#         y <- "*"
#     } else {y <- ""}
#     y
# })

plt <- reshape2::melt(plt, id.vars = c("mapinfo", "Padj"))
plt <- merge(plt, meta.t, by.x = "variable", by.y = 0)


ggplot(plt, aes(x = as.character(mapinfo), y = value, color = Disease_Status, shape = Disease_Status, alpha = Disease_Status)) + 
    geom_point(size = 2) + 
    # geom_line(aes(group = Disease_Status)) + 
    theme_bw() + 
    stat_summary(fun.y = "mean", geom = "line", aes(group = Disease_Status, size = Disease_Status)) +
    scale_color_manual(values = c("HC_EV" =  "#5E81ACFF", 
                                  "Patient_EV" = "#40346A", 
                                  "Patient_WT" ="#45AB9A")) + 
    scale_shape_manual(values = c("HC_EV" = 16, 
                                  "Patient_EV" = 17, 
                                  "Patient_WT" = 15)) +
    scale_size_manual(values = c("HC_EV" = 1.2, 
                                 "Patient_EV" = 1.2, 
                                 "Patient_WT" = 1.2)) + 
    scale_alpha_manual(values = c("HC_EV" = 0.5, 
                                 "Patient_EV" = 0.8, 
                                 "Patient_WT" = 0.5)) +
    theme(axis.text.x = element_text(angle = 20, vjust = 1, hjust = 1), 
          text = element_text(size = 15))
```

```{r}
### IL4
cpgs <- rownames(anno)[grepl("IL4", anno$UCSC_REFGENE_NAME)& anno$CHR == 5]
cpgs <- rownames(anno)[grepl("TNF", anno$UCSC_REFGENE_NAME)& anno$CHR == 6 & anno$MAPINFO >= 31574682 & anno$MAPINFO <= 31578308]
(gene <- anno[grep("RAB27A", anno$UCSC_REFGENE_NAME), c("CHR", "MAPINFO", "STRAND", "UCSC_REFGENE_NAME", "UCSC_REFGENE_GROUP"), ])
(gene <- anno[grep("UNC13D", anno$UCSC_REFGENE_NAME), c("CHR", "MAPINFO", "STRAND", "UCSC_REFGENE_NAME", "UCSC_REFGENE_GROUP"), ])
(gene <- anno[grep("PRF1", anno$UCSC_REFGENE_NAME), c("CHR", "MAPINFO", "STRAND", "UCSC_REFGENE_NAME", "UCSC_REFGENE_GROUP"), ])
(gene <- anno[grep("B3GAT1", anno$UCSC_REFGENE_NAME), c("CHR", "MAPINFO", "STRAND", "UCSC_REFGENE_NAME", "UCSC_REFGENE_GROUP"), ])
(gene <- anno[grep("ITGAL", anno$UCSC_REFGENE_NAME), c("CHR", "MAPINFO", "STRAND", "UCSC_REFGENE_NAME", "UCSC_REFGENE_GROUP"), ])
cpgs <- rownames(gene)

plt <- beta.t[cpgs, c("HC1_T2", "HC3_T2", "HC2_T2", "Dad_T2", "Sister_T2", "Mom_T2", "P1_T2", "P2_T2", "P3_T2", "R1_T2", "R2_T2", "R3_T2")] %>%
    as.data.frame(.)
plt$mapinfo <- anno[cpgs, "MAPINFO"] %>% 
    as.character() #%>%
    # factor(., levels = rev(.))
plt$Padj <- limmaOut.EV[cpgs, "adj.P.Val"]

plt <- reshape2::melt(plt, id.vars = c("mapinfo", "Padj"))
plt <- merge(plt, meta.t, by.x = "variable", by.y = 0)


ggplot(plt, aes(x = mapinfo, y = value, color = Disease_Status, shape = Disease_Status, alpha = Disease_Status)) + 
    geom_point(size = 2) + 
    # geom_line(aes(group = Disease_Status)) + 
    theme_bw() + 
    stat_summary(fun.y = "mean", geom = "line", aes(group = Disease_Status, size = Disease_Status)) +
    scale_color_manual(values = c("HC_EV" =  "#5E81ACFF", 
                                  "Patient_EV" = "#40346A", 
                                  "Patient_WT" ="#45AB9A")) + 
    scale_shape_manual(values = c("HC_EV" = 16, 
                                  "Patient_EV" = 17, 
                                  "Patient_WT" = 15)) +
    scale_size_manual(values = c("HC_EV" = 1.2, 
                                 "Patient_EV" = 1.2, 
                                 "Patient_WT" = 1.2)) + 
    scale_alpha_manual(values = c("HC_EV" = 0.5, 
                                 "Patient_EV" = 0.8, 
                                 "Patient_WT" = 0.5)) +
    theme(axis.text.x = element_text(angle = 20, vjust = 1, hjust = 1), 
          text = element_text(size = 15)) + 
    labs(x = "", y = "Average DNAm level", title = "UNC13D")

test <- limmaOut.EV[cpgs, ]
test$star <- apply(test, 1, function(x) {
    if(x["adj.P.Val"] < 0.2) {
        y <- "*"
    } else {y <- ""}
    y
})
```

